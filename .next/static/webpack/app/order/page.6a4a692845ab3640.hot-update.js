"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/order/page",{

/***/ "(app-pages-browser)/./app/services/order.ts":
/*!*******************************!*\
  !*** ./app/services/order.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOrder: () => (/* binding */ createOrder),\n/* harmony export */   deleteOrder: () => (/* binding */ deleteOrder),\n/* harmony export */   getOrder: () => (/* binding */ getOrder),\n/* harmony export */   getOrders: () => (/* binding */ getOrders),\n/* harmony export */   updateOrderStatus: () => (/* binding */ updateOrderStatus)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabaseUrl = \"https://pslapwodbwhedywmlfmk.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBzbGFwd29kYndoZWR5d21sZm1rIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA1NTQ4NzgsImV4cCI6MjA1NjEzMDg3OH0.YXR7RN1ELBO8ywDv_tXpioTFJrpNXr9UtDLhxzgcHmU\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\nasync function getOrders(filters) {\n    let guestMode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    try {\n        // Guest mode - only for viewing orders for a specific unit\n        if (guestMode) {\n            if (!(filters === null || filters === void 0 ? void 0 : filters.unit_id)) {\n                console.warn('Guest mode requires unit_id filter');\n                return [];\n            }\n            let query = supabase.from('orders').select(\"\\n          *,\\n          order_items:order_items(*)\\n        \").eq('unit_id', filters.unit_id).order('created_at', {\n                ascending: false\n            });\n            if (filters.status) {\n                query = query.eq('status', filters.status);\n            }\n            const { data, error } = await query;\n            if (error) {\n                console.error('Supabase error:', error);\n                throw new Error(\"Failed to fetch orders: \".concat(error.message));\n            }\n            return data;\n        }\n        // Admin mode - require authentication and verify ownership\n        // Get the current authenticated user\n        const { data: { user }, error: userError } = await supabase.auth.getUser();\n        if (userError) {\n            console.error('Auth error:', userError);\n            throw new Error(\"Failed to get current user: \".concat(userError.message));\n        }\n        if (!user) {\n            console.warn('No authenticated user found');\n            return [];\n        }\n        // First, get the list of buildings owned by this user\n        const { data: userBuildings, error: buildingsError } = await supabase.from('buildings').select('id').eq('user_id', user.id);\n        if (buildingsError) {\n            console.error('Supabase error fetching buildings:', buildingsError);\n            throw new Error(\"Failed to fetch user buildings: \".concat(buildingsError.message));\n        }\n        const userBuildingIds = (userBuildings === null || userBuildings === void 0 ? void 0 : userBuildings.map((b)=>b.id)) || [];\n        if (userBuildingIds.length === 0) {\n            return [];\n        }\n        let query = supabase.from('orders').select(\"\\n        *,\\n        order_items:order_items(*)\\n      \").in('building_id', userBuildingIds).order('created_at', {\n            ascending: false\n        });\n        if (filters) {\n            if (filters.unit_id) {\n                query = query.eq('unit_id', filters.unit_id);\n            }\n            if (filters.building_id) {\n                // Verify the building belongs to the user before filtering\n                if (userBuildingIds.includes(filters.building_id)) {\n                    query = query.eq('building_id', filters.building_id);\n                } else {\n                    console.warn(\"Building \".concat(filters.building_id, \" does not belong to user \").concat(user.id));\n                    return [];\n                }\n            }\n            if (filters.status) {\n                query = query.eq('status', filters.status);\n            }\n        }\n        const { data, error } = await query;\n        if (error) {\n            console.error('Supabase error:', error);\n            throw new Error(\"Failed to fetch orders: \".concat(error.message));\n        }\n        if (!data) {\n            return [];\n        }\n        return data;\n    } catch (error) {\n        console.error('Error in getOrders:', error);\n        throw error;\n    }\n}\nasync function getOrder(id) {\n    let guestMode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    try {\n        // Guest mode - skip authentication for order page (QR code access)\n        if (guestMode) {\n            const { data, error } = await supabase.from('orders').select(\"\\n          *,\\n          order_items:order_items(*)\\n        \").eq('id', id).single();\n            if (error) {\n                return null;\n            }\n            if (!data) {\n                return null;\n            }\n            return data;\n        }\n        // Admin mode - require authentication and verify ownership\n        // Get the current authenticated user\n        const { data: { user } } = await supabase.auth.getUser();\n        if (!user) {\n            throw new Error('You must be logged in to view order details');\n        }\n        // Get the user's buildings\n        const { data: userBuildings } = await supabase.from('buildings').select('id').eq('user_id', user.id);\n        const userBuildingIds = (userBuildings === null || userBuildings === void 0 ? void 0 : userBuildings.map((b)=>b.id)) || [];\n        const { data, error } = await supabase.from('orders').select(\"\\n        *,\\n        order_items:order_items(*)\\n      \").eq('id', id).single();\n        if (error) {\n            return null;\n        }\n        if (!data) {\n            return null;\n        }\n        // Check if this order belongs to one of the user's buildings\n        if (!userBuildingIds.includes(data.building_id)) {\n            console.warn(\"Order \".concat(id, \" does not belong to any building owned by user \").concat(user.id));\n            return null;\n        }\n        return data;\n    } catch (error) {\n        console.error('Error in getOrder:', error);\n        throw error;\n    }\n}\nasync function createOrder(orderInput) {\n    try {\n        // Calculate total amount based on prices and quantities\n        const totalAmount = orderInput.items.reduce((sum, item)=>sum + item.price * item.quantity, 0);\n        // Verify the building exists\n        const { data: buildingCheck } = await supabase.from('buildings').select('id').eq('id', orderInput.building_id).single();\n        if (!buildingCheck) {\n            throw new Error(\"Building with ID \".concat(orderInput.building_id, \" does not exist\"));\n        }\n        // Create the order first\n        const { data: orderData, error: orderError } = await supabase.from('orders').insert([\n            {\n                unit_id: orderInput.unit_id,\n                unit_number: orderInput.unit_number,\n                building_id: orderInput.building_id,\n                building_name: orderInput.building_name,\n                status: 'pending',\n                total_amount: totalAmount,\n                notes: orderInput.notes || ''\n            }\n        ]).select().single();\n        if (orderError) {\n            console.error('Error creating order:', orderError);\n            throw orderError;\n        }\n        if (!orderData) {\n            throw new Error('No data returned after creating order');\n        }\n        // Now create all the order items\n        const orderItems = orderInput.items.map((item)=>({\n                order_id: orderData.id,\n                item_type: item.item_type,\n                item_id: item.item_id,\n                name: item.name,\n                price: item.price,\n                quantity: item.quantity,\n                notes: item.notes || ''\n            }));\n        const { error: itemsError } = await supabase.from('order_items').insert(orderItems);\n        if (itemsError) {\n            console.error('Error creating order items:', itemsError);\n            // If there's an error creating order items, delete the order to maintain consistency\n            const { error: deleteError } = await supabase.from('orders').delete().eq('id', orderData.id);\n            if (deleteError) {\n                console.error('Error deleting order after failed items creation:', deleteError);\n            }\n            throw itemsError;\n        }\n        // Finally, fetch the complete order with items\n        return await getOrder(orderData.id);\n    } catch (error) {\n        console.error('Error in createOrder:', error);\n        throw error;\n    }\n}\nasync function updateOrderStatus(updateInput) {\n    try {\n        // Get the current authenticated user\n        const { data: { user } } = await supabase.auth.getUser();\n        if (!user) {\n            throw new Error('You must be logged in to update an order');\n        }\n        // Get the user's buildings\n        const { data: userBuildings } = await supabase.from('buildings').select('id').eq('user_id', user.id);\n        const userBuildingIds = (userBuildings === null || userBuildings === void 0 ? void 0 : userBuildings.map((b)=>b.id)) || [];\n        // First check if the order belongs to one of the user's buildings\n        const { data: orderData } = await supabase.from('orders').select('building_id').eq('id', updateInput.id).single();\n        if (!orderData || !userBuildingIds.includes(orderData.building_id)) {\n            throw new Error('You do not have permission to update this order');\n        }\n        const { data, error } = await supabase.from('orders').update({\n            status: updateInput.status,\n            updated_at: new Date().toISOString()\n        }).eq('id', updateInput.id).select().single();\n        if (error) {\n            throw error;\n        }\n        return await getOrder(updateInput.id);\n    } catch (error) {\n        console.error('Error in updateOrderStatus:', error);\n        throw error;\n    }\n}\nasync function deleteOrder(id) {\n    try {\n        // Get the current authenticated user\n        const { data: { user } } = await supabase.auth.getUser();\n        if (!user) {\n            throw new Error('You must be logged in to delete an order');\n        }\n        // Get the user's buildings\n        const { data: userBuildings } = await supabase.from('buildings').select('id').eq('user_id', user.id);\n        const userBuildingIds = (userBuildings === null || userBuildings === void 0 ? void 0 : userBuildings.map((b)=>b.id)) || [];\n        // First check if the order belongs to one of the user's buildings\n        const { data: orderData } = await supabase.from('orders').select('building_id').eq('id', id).single();\n        if (!orderData || !userBuildingIds.includes(orderData.building_id)) {\n            throw new Error('You do not have permission to delete this order');\n        }\n        // Delete the order - the cascade constraint will handle deleting associated items\n        const { error } = await supabase.from('orders').delete().eq('id', id);\n        if (error) {\n            throw error;\n        }\n    } catch (error) {\n        console.error('Error in deleteOrder:', error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9vcmRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBcUQ7QUFHckQsTUFBTUMsY0FBY0MsMENBQW9DO0FBQ3hELE1BQU1HLGtCQUFrQkgsa05BQXlDO0FBQ2pFLE1BQU1LLFdBQVdQLG1FQUFZQSxDQUFDQyxhQUFhSTtBQUVwQyxlQUFlRyxVQUFVQyxPQUkvQjtRQUFFQyxZQUFBQSxpRUFBcUI7SUFDdEIsSUFBSTtRQUNGLDJEQUEyRDtRQUMzRCxJQUFJQSxXQUFXO1lBQ2IsSUFBSSxFQUFDRCxvQkFBQUEsOEJBQUFBLFFBQVNFLE9BQU8sR0FBRTtnQkFDckJDLFFBQVFDLElBQUksQ0FBQztnQkFDYixPQUFPLEVBQUU7WUFDWDtZQUVBLElBQUlDLFFBQVFQLFNBQ1RRLElBQUksQ0FBQyxVQUNMQyxNQUFNLENBQUUsa0VBSVJDLEVBQUUsQ0FBQyxXQUFXUixRQUFRRSxPQUFPLEVBQzdCTyxLQUFLLENBQUMsY0FBYztnQkFBRUMsV0FBVztZQUFNO1lBRTFDLElBQUlWLFFBQVFXLE1BQU0sRUFBRTtnQkFDbEJOLFFBQVFBLE1BQU1HLEVBQUUsQ0FBQyxVQUFVUixRQUFRVyxNQUFNO1lBQzNDO1lBRUEsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1SO1lBRTlCLElBQUlRLE9BQU87Z0JBQ1RWLFFBQVFVLEtBQUssQ0FBQyxtQkFBbUJBO2dCQUNqQyxNQUFNLElBQUlDLE1BQU0sMkJBQXlDLE9BQWRELE1BQU1FLE9BQU87WUFDMUQ7WUFFQSxPQUFPSDtRQUNUO1FBRUEsMkRBQTJEO1FBQzNELHFDQUFxQztRQUNyQyxNQUFNLEVBQUVBLE1BQU0sRUFBRUksSUFBSSxFQUFFLEVBQUVILE9BQU9JLFNBQVMsRUFBRSxHQUFHLE1BQU1uQixTQUFTb0IsSUFBSSxDQUFDQyxPQUFPO1FBRXhFLElBQUlGLFdBQVc7WUFDYmQsUUFBUVUsS0FBSyxDQUFDLGVBQWVJO1lBQzdCLE1BQU0s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LGdCQUFnQk0sUUFBUSxDQUFDYSxVQUFVZCxXQUFXLEdBQUc7WUFDbEUsTUFBTSxJQUFJZCxNQUFNO1FBQ2xCO1FBRUEsa0ZBQWtGO1FBQ2xGLE1BQU0sRUFBRUQsS0FBSyxFQUFFLEdBQUcsTUFBTWYsU0FDckJRLElBQUksQ0FBQyxVQUNMa0QsTUFBTSxHQUNOaEQsRUFBRSxDQUFDLE1BQU1jO1FBRVosSUFBSVQsT0FBTztZQUNULE1BQU1BO1FBQ1I7SUFDRixFQUFFLE9BQU9BLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLHlCQUF5QkE7UUFDdkMsTUFBTUE7SUFDUjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvam9lbGt3b2gvRG9jdW1lbnRzL0dpdEh1Yi9teXFyY29kZS1odWIvYXBwL3NlcnZpY2VzL29yZGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyBPcmRlciwgQ3JlYXRlT3JkZXJJbnB1dCwgVXBkYXRlT3JkZXJTdGF0dXNJbnB1dCwgT3JkZXJJdGVtIH0gZnJvbSAnLi4vdHlwZXMvb3JkZXInO1xuXG5jb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCE7XG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSE7XG5jb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9yZGVycyhmaWx0ZXJzPzoge1xuICB1bml0X2lkPzogc3RyaW5nO1xuICBidWlsZGluZ19pZD86IHN0cmluZztcbiAgc3RhdHVzPzogc3RyaW5nO1xufSwgZ3Vlc3RNb2RlOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPE9yZGVyW10+IHtcbiAgdHJ5IHtcbiAgICAvLyBHdWVzdCBtb2RlIC0gb25seSBmb3Igdmlld2luZyBvcmRlcnMgZm9yIGEgc3BlY2lmaWMgdW5pdFxuICAgIGlmIChndWVzdE1vZGUpIHtcbiAgICAgIGlmICghZmlsdGVycz8udW5pdF9pZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0d1ZXN0IG1vZGUgcmVxdWlyZXMgdW5pdF9pZCBmaWx0ZXInKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgXG4gICAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnb3JkZXJzJylcbiAgICAgICAgLnNlbGVjdChgXG4gICAgICAgICAgKixcbiAgICAgICAgICBvcmRlcl9pdGVtczpvcmRlcl9pdGVtcygqKVxuICAgICAgICBgKVxuICAgICAgICAuZXEoJ3VuaXRfaWQnLCBmaWx0ZXJzLnVuaXRfaWQpXG4gICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgIFxuICAgICAgaWYgKGZpbHRlcnMuc3RhdHVzKSB7XG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ3N0YXR1cycsIGZpbHRlcnMuc3RhdHVzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIG9yZGVyczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZGF0YSBhcyBPcmRlcltdO1xuICAgIH1cbiAgXG4gICAgLy8gQWRtaW4gbW9kZSAtIHJlcXVpcmUgYXV0aGVudGljYXRpb24gYW5kIHZlcmlmeSBvd25lcnNoaXBcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRlZCB1c2VyXG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgXG4gICAgaWYgKHVzZXJFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQXV0aCBlcnJvcjonLCB1c2VyRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IGN1cnJlbnQgdXNlcjogJHt1c2VyRXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIGF1dGhlbnRpY2F0ZWQgdXNlciBmb3VuZCcpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICAvLyBGaXJzdCwgZ2V0IHRoZSBsaXN0IG9mIGJ1aWxkaW5ncyBvd25lZCBieSB0aGlzIHVzZXJcbiAgICBjb25zdCB7IGRhdGE6IHVzZXJCdWlsZGluZ3MsIGVycm9yOiBidWlsZGluZ3NFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdidWlsZGluZ3MnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZCk7XG4gICAgICBcbiAgICBpZiAoYnVpbGRpbmdzRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIGZldGNoaW5nIGJ1aWxkaW5nczonLCBidWlsZGluZ3NFcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCB1c2VyIGJ1aWxkaW5nczogJHtidWlsZGluZ3NFcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB1c2VyQnVpbGRpbmdJZHMgPSB1c2VyQnVpbGRpbmdzPy5tYXAoYiA9PiBiLmlkKSB8fCBbXTtcbiAgICBcbiAgICBpZiAodXNlckJ1aWxkaW5nSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxuICAgICAgLmZyb20oJ29yZGVycycpXG4gICAgICAuc2VsZWN0KGBcbiAgICAgICAgKixcbiAgICAgICAgb3JkZXJfaXRlbXM6b3JkZXJfaXRlbXMoKilcbiAgICAgIGApXG4gICAgICAuaW4oJ2J1aWxkaW5nX2lkJywgdXNlckJ1aWxkaW5nSWRzKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuICAgIFxuICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICBpZiAoZmlsdGVycy51bml0X2lkKSB7XG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ3VuaXRfaWQnLCBmaWx0ZXJzLnVuaXRfaWQpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbHRlcnMuYnVpbGRpbmdfaWQpIHtcbiAgICAgICAgLy8gVmVyaWZ5IHRoZSBidWlsZGluZyBiZWxvbmdzIHRvIHRoZSB1c2VyIGJlZm9yZSBmaWx0ZXJpbmdcbiAgICAgICAgaWYgKHVzZXJCdWlsZGluZ0lkcy5pbmNsdWRlcyhmaWx0ZXJzLmJ1aWxkaW5nX2lkKSkge1xuICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ2J1aWxkaW5nX2lkJywgZmlsdGVycy5idWlsZGluZ19pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBCdWlsZGluZyAke2ZpbHRlcnMuYnVpbGRpbmdfaWR9IGRvZXMgbm90IGJlbG9uZyB0byB1c2VyICR7dXNlci5pZH1gKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXJzLnN0YXR1cykge1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdzdGF0dXMnLCBmaWx0ZXJzLnN0YXR1cyk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBvcmRlcnM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSBhcyBPcmRlcltdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldE9yZGVyczonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9yZGVyKGlkOiBzdHJpbmcsIGd1ZXN0TW9kZTogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTxPcmRlciB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICAvLyBHdWVzdCBtb2RlIC0gc2tpcCBhdXRoZW50aWNhdGlvbiBmb3Igb3JkZXIgcGFnZSAoUVIgY29kZSBhY2Nlc3MpXG4gICAgaWYgKGd1ZXN0TW9kZSkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ29yZGVycycpXG4gICAgICAgIC5zZWxlY3QoYFxuICAgICAgICAgICosXG4gICAgICAgICAgb3JkZXJfaXRlbXM6b3JkZXJfaXRlbXMoKilcbiAgICAgICAgYClcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YSBhcyBPcmRlcjtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRtaW4gbW9kZSAtIHJlcXVpcmUgYXV0aGVudGljYXRpb24gYW5kIHZlcmlmeSBvd25lcnNoaXBcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRlZCB1c2VyXG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgXG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGJlIGxvZ2dlZCBpbiB0byB2aWV3IG9yZGVyIGRldGFpbHMnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IHRoZSB1c2VyJ3MgYnVpbGRpbmdzXG4gICAgY29uc3QgeyBkYXRhOiB1c2VyQnVpbGRpbmdzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2J1aWxkaW5ncycpXG4gICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKTtcbiAgICAgIFxuICAgIGNvbnN0IHVzZXJCdWlsZGluZ0lkcyA9IHVzZXJCdWlsZGluZ3M/Lm1hcChiID0+IGIuaWQpIHx8IFtdO1xuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnb3JkZXJzJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICBvcmRlcl9pdGVtczpvcmRlcl9pdGVtcygqKVxuICAgICAgYClcbiAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBvcmRlciBiZWxvbmdzIHRvIG9uZSBvZiB0aGUgdXNlcidzIGJ1aWxkaW5nc1xuICAgIGlmICghdXNlckJ1aWxkaW5nSWRzLmluY2x1ZGVzKGRhdGEuYnVpbGRpbmdfaWQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE9yZGVyICR7aWR9IGRvZXMgbm90IGJlbG9uZyB0byBhbnkgYnVpbGRpbmcgb3duZWQgYnkgdXNlciAke3VzZXIuaWR9YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSBhcyBPcmRlcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRPcmRlcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU9yZGVyKG9yZGVySW5wdXQ6IENyZWF0ZU9yZGVySW5wdXQpOiBQcm9taXNlPE9yZGVyPiB7XG4gIHRyeSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRvdGFsIGFtb3VudCBiYXNlZCBvbiBwcmljZXMgYW5kIHF1YW50aXRpZXNcbiAgICBjb25zdCB0b3RhbEFtb3VudCA9IG9yZGVySW5wdXQuaXRlbXMucmVkdWNlKFxuICAgICAgKHN1bSwgaXRlbSkgPT4gc3VtICsgKGl0ZW0ucHJpY2UgKiBpdGVtLnF1YW50aXR5KSwgXG4gICAgICAwXG4gICAgKTtcbiAgICBcbiAgICAvLyBWZXJpZnkgdGhlIGJ1aWxkaW5nIGV4aXN0c1xuICAgIGNvbnN0IHsgZGF0YTogYnVpbGRpbmdDaGVjayB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdidWlsZGluZ3MnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmVxKCdpZCcsIG9yZGVySW5wdXQuYnVpbGRpbmdfaWQpXG4gICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICBpZiAoIWJ1aWxkaW5nQ2hlY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQnVpbGRpbmcgd2l0aCBJRCAke29yZGVySW5wdXQuYnVpbGRpbmdfaWR9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHRoZSBvcmRlciBmaXJzdFxuICAgIGNvbnN0IHsgZGF0YTogb3JkZXJEYXRhLCBlcnJvcjogb3JkZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdvcmRlcnMnKVxuICAgICAgLmluc2VydChbe1xuICAgICAgICB1bml0X2lkOiBvcmRlcklucHV0LnVuaXRfaWQsXG4gICAgICAgIHVuaXRfbnVtYmVyOiBvcmRlcklucHV0LnVuaXRfbnVtYmVyLFxuICAgICAgICBidWlsZGluZ19pZDogb3JkZXJJbnB1dC5idWlsZGluZ19pZCxcbiAgICAgICAgYnVpbGRpbmdfbmFtZTogb3JkZXJJbnB1dC5idWlsZGluZ19uYW1lLFxuICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgdG90YWxfYW1vdW50OiB0b3RhbEFtb3VudCxcbiAgICAgICAgbm90ZXM6IG9yZGVySW5wdXQubm90ZXMgfHwgJydcbiAgICAgIH1dKVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAob3JkZXJFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgb3JkZXI6Jywgb3JkZXJFcnJvcik7XG4gICAgICB0aHJvdyBvcmRlckVycm9yO1xuICAgIH1cblxuICAgIGlmICghb3JkZXJEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGEgcmV0dXJuZWQgYWZ0ZXIgY3JlYXRpbmcgb3JkZXInKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgY3JlYXRlIGFsbCB0aGUgb3JkZXIgaXRlbXNcbiAgICBjb25zdCBvcmRlckl0ZW1zID0gb3JkZXJJbnB1dC5pdGVtcy5tYXAoaXRlbSA9PiAoe1xuICAgICAgb3JkZXJfaWQ6IG9yZGVyRGF0YS5pZCxcbiAgICAgIGl0ZW1fdHlwZTogaXRlbS5pdGVtX3R5cGUsXG4gICAgICBpdGVtX2lkOiBpdGVtLml0ZW1faWQsXG4gICAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgICBwcmljZTogaXRlbS5wcmljZSxcbiAgICAgIHF1YW50aXR5OiBpdGVtLnF1YW50aXR5LFxuICAgICAgbm90ZXM6IGl0ZW0ubm90ZXMgfHwgJydcbiAgICB9KSk7XG5cbiAgICBjb25zdCB7IGVycm9yOiBpdGVtc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ29yZGVyX2l0ZW1zJylcbiAgICAgIC5pbnNlcnQob3JkZXJJdGVtcyk7XG5cbiAgICBpZiAoaXRlbXNFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgb3JkZXIgaXRlbXM6JywgaXRlbXNFcnJvcik7XG4gICAgICBcbiAgICAgIC8vIElmIHRoZXJlJ3MgYW4gZXJyb3IgY3JlYXRpbmcgb3JkZXIgaXRlbXMsIGRlbGV0ZSB0aGUgb3JkZXIgdG8gbWFpbnRhaW4gY29uc2lzdGVuY3lcbiAgICAgIGNvbnN0IHsgZXJyb3I6IGRlbGV0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnb3JkZXJzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgnaWQnLCBvcmRlckRhdGEuaWQpO1xuICAgICAgXG4gICAgICBpZiAoZGVsZXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgb3JkZXIgYWZ0ZXIgZmFpbGVkIGl0ZW1zIGNyZWF0aW9uOicsIGRlbGV0ZUVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgaXRlbXNFcnJvcjtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGx5LCBmZXRjaCB0aGUgY29tcGxldGUgb3JkZXIgd2l0aCBpdGVtc1xuICAgIHJldHVybiBhd2FpdCBnZXRPcmRlcihvcmRlckRhdGEuaWQpIGFzIE9yZGVyO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGNyZWF0ZU9yZGVyOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlT3JkZXJTdGF0dXModXBkYXRlSW5wdXQ6IFVwZGF0ZU9yZGVyU3RhdHVzSW5wdXQpOiBQcm9taXNlPE9yZGVyPiB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0ZWQgdXNlclxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgIFxuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBiZSBsb2dnZWQgaW4gdG8gdXBkYXRlIGFuIG9yZGVyJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEdldCB0aGUgdXNlcidzIGJ1aWxkaW5nc1xuICAgIGNvbnN0IHsgZGF0YTogdXNlckJ1aWxkaW5ncyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdidWlsZGluZ3MnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZCk7XG4gICAgICBcbiAgICBjb25zdCB1c2VyQnVpbGRpbmdJZHMgPSB1c2VyQnVpbGRpbmdzPy5tYXAoYiA9PiBiLmlkKSB8fCBbXTtcbiAgICBcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgb3JkZXIgYmVsb25ncyB0byBvbmUgb2YgdGhlIHVzZXIncyBidWlsZGluZ3NcbiAgICBjb25zdCB7IGRhdGE6IG9yZGVyRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdvcmRlcnMnKVxuICAgICAgLnNlbGVjdCgnYnVpbGRpbmdfaWQnKVxuICAgICAgLmVxKCdpZCcsIHVwZGF0ZUlucHV0LmlkKVxuICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgaWYgKCFvcmRlckRhdGEgfHwgIXVzZXJCdWlsZGluZ0lkcy5pbmNsdWRlcyhvcmRlckRhdGEuYnVpbGRpbmdfaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHVwZGF0ZSB0aGlzIG9yZGVyJyk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnb3JkZXJzJylcbiAgICAgIC51cGRhdGUoeyBcbiAgICAgICAgc3RhdHVzOiB1cGRhdGVJbnB1dC5zdGF0dXMsXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSlcbiAgICAgIC5lcSgnaWQnLCB1cGRhdGVJbnB1dC5pZClcbiAgICAgIC5zZWxlY3QoKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgZ2V0T3JkZXIodXBkYXRlSW5wdXQuaWQpIGFzIE9yZGVyO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHVwZGF0ZU9yZGVyU3RhdHVzOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlT3JkZXIoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBhdXRoZW50aWNhdGVkIHVzZXJcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICBcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgYmUgbG9nZ2VkIGluIHRvIGRlbGV0ZSBhbiBvcmRlcicpO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgdGhlIHVzZXIncyBidWlsZGluZ3NcbiAgICBjb25zdCB7IGRhdGE6IHVzZXJCdWlsZGluZ3MgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYnVpbGRpbmdzJylcbiAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpO1xuICAgICAgXG4gICAgY29uc3QgdXNlckJ1aWxkaW5nSWRzID0gdXNlckJ1aWxkaW5ncz8ubWFwKGIgPT4gYi5pZCkgfHwgW107XG4gICAgXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIG9yZGVyIGJlbG9uZ3MgdG8gb25lIG9mIHRoZSB1c2VyJ3MgYnVpbGRpbmdzXG4gICAgY29uc3QgeyBkYXRhOiBvcmRlckRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnb3JkZXJzJylcbiAgICAgIC5zZWxlY3QoJ2J1aWxkaW5nX2lkJylcbiAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgIC5zaW5nbGUoKTtcbiAgICAgIFxuICAgIGlmICghb3JkZXJEYXRhIHx8ICF1c2VyQnVpbGRpbmdJZHMuaW5jbHVkZXMob3JkZXJEYXRhLmJ1aWxkaW5nX2lkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBkZWxldGUgdGhpcyBvcmRlcicpO1xuICAgIH1cbiAgICBcbiAgICAvLyBEZWxldGUgdGhlIG9yZGVyIC0gdGhlIGNhc2NhZGUgY29uc3RyYWludCB3aWxsIGhhbmRsZSBkZWxldGluZyBhc3NvY2lhdGVkIGl0ZW1zXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdvcmRlcnMnKVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAuZXEoJ2lkJywgaWQpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZGVsZXRlT3JkZXI6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59ICJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJzdXBhYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZUFub25LZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsInN1cGFiYXNlIiwiZ2V0T3JkZXJzIiwiZmlsdGVycyIsImd1ZXN0TW9kZSIsInVuaXRfaWQiLCJjb25zb2xlIiwid2FybiIsInF1ZXJ5IiwiZnJvbSIsInNlbGVjdCIsImVxIiwib3JkZXIiLCJhc2NlbmRpbmciLCJzdGF0dXMiLCJkYXRhIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJ1c2VyIiwidXNlckVycm9yIiwiYXV0aCIsImdldFVzZXIiLCJ1c2VyQnVpbGRpbmdzIiwiYnVpbGRpbmdzRXJyb3IiLCJpZCIsInVzZXJCdWlsZGluZ0lkcyIsIm1hcCIsImIiLCJsZW5ndGgiLCJpbiIsImJ1aWxkaW5nX2lkIiwiaW5jbHVkZXMiLCJnZXRPcmRlciIsInNpbmdsZSIsImNyZWF0ZU9yZGVyIiwib3JkZXJJbnB1dCIsInRvdGFsQW1vdW50IiwiaXRlbXMiLCJyZWR1Y2UiLCJzdW0iLCJpdGVtIiwicHJpY2UiLCJxdWFudGl0eSIsImJ1aWxkaW5nQ2hlY2siLCJvcmRlckRhdGEiLCJvcmRlckVycm9yIiwiaW5zZXJ0IiwidW5pdF9udW1iZXIiLCJidWlsZGluZ19uYW1lIiwidG90YWxfYW1vdW50Iiwibm90ZXMiLCJvcmRlckl0ZW1zIiwib3JkZXJfaWQiLCJpdGVtX3R5cGUiLCJpdGVtX2lkIiwibmFtZSIsIml0ZW1zRXJyb3IiLCJkZWxldGVFcnJvciIsImRlbGV0ZSIsInVwZGF0ZU9yZGVyU3RhdHVzIiwidXBkYXRlSW5wdXQiLCJ1cGRhdGUiLCJ1cGRhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZGVsZXRlT3JkZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/order.ts\n"));

/***/ })

});