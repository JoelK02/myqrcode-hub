"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/order/page",{

/***/ "(app-pages-browser)/./app/services/service.ts":
/*!*********************************!*\
  !*** ./app/services/service.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createService: () => (/* binding */ createService),\n/* harmony export */   deleteService: () => (/* binding */ deleteService),\n/* harmony export */   getService: () => (/* binding */ getService),\n/* harmony export */   getServices: () => (/* binding */ getServices),\n/* harmony export */   updateService: () => (/* binding */ updateService)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\n// Initialize Supabase client\nconst supabaseUrl = \"https://pslapwodbwhedywmlfmk.supabase.co\" || 0;\nconst supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBzbGFwd29kYndoZWR5d21sZm1rIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA1NTQ4NzgsImV4cCI6MjA1NjEzMDg3OH0.YXR7RN1ELBO8ywDv_tXpioTFJrpNXr9UtDLhxzgcHmU\" || 0;\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseKey);\nconst getServices = async (category, building_id)=>{\n    try {\n        // Guest mode - if building_id is provided, we don't need to check user auth\n        // This allows guests viewing the services to see items without logging in\n        if (building_id) {\n            let query = supabase.from('services').select('*').eq('building_id', building_id).order('name');\n            if (category) {\n                query = query.eq('category', category);\n            }\n            const { data, error } = await query;\n            if (error) {\n                console.error('Error fetching services:', error);\n                throw new Error(error.message);\n            }\n            return data || [];\n        }\n        // Admin mode - get user's buildings and filter services\n        const { data: { user }, error: userError } = await supabase.auth.getUser();\n        if (userError) {\n            console.error('Auth error:', userError);\n            throw new Error(\"Failed to get current user: \".concat(userError.message));\n        }\n        if (!user) {\n            console.warn('No authenticated user found');\n            return [];\n        }\n        // Get the buildings owned by this user\n        const { data: userBuildings, error: buildingsError } = await supabase.from('buildings').select('id').eq('user_id', user.id);\n        if (buildingsError) {\n            console.error('Supabase error fetching buildings:', buildingsError);\n            throw new Error(\"Failed to fetch user buildings: \".concat(buildingsError.message));\n        }\n        const userBuildingIds = (userBuildings === null || userBuildings === void 0 ? void 0 : userBuildings.map((b)=>b.id)) || [];\n        if (userBuildingIds.length === 0) {\n            return [];\n        }\n        let query = supabase.from('services').select('*').in('building_id', userBuildingIds).order('name');\n        if (category) {\n            query = query.eq('category', category);\n        }\n        const { data, error } = await query;\n        if (error) {\n            console.error('Error fetching services:', error);\n            throw new Error(error.message);\n        }\n        return data || [];\n    } catch (error) {\n        console.error('Error in getServices:', error);\n        throw error;\n    }\n};\nconst getService = async (id)=>{\n    try {\n        // First get the service\n        const { data, error } = await supabase.from('services').select('*').eq('id', id).single();\n        if (error) {\n            console.error('Error fetching service:', error);\n            throw new Error(error.message);\n        }\n        // For admin operations, check if this belongs to user's building\n        if (id && \"object\" !== 'undefined') {\n            // Check if we're in admin mode (not the order page)\n            const isAdminMode = !window.location.pathname.startsWith('/order');\n            if (isAdminMode) {\n                // Get the current user\n                const { data: { user } } = await supabase.auth.getUser();\n                if (user) {\n                    // Verify this service belongs to a building owned by the user\n                    const { data: buildingCheck } = await supabase.from('buildings').select('id').eq('id', data.building_id).eq('user_id', user.id).single();\n                    if (!buildingCheck) {\n                        throw new Error('You do not have permission to access this service');\n                    }\n                }\n            }\n        }\n        return data;\n    } catch (error) {\n        console.error('Error in getService:', error);\n        throw error;\n    }\n};\nconst createService = async (service)=>{\n    try {\n        // Get the current authenticated user\n        const { data: { user } } = await supabase.auth.getUser();\n        if (!user) {\n            throw new Error('You must be logged in to create a service');\n        }\n        // Check if the building belongs to the user\n        if (service.building_id) {\n            const { data: buildingCheck } = await supabase.from('buildings').select('id').eq('id', service.building_id).eq('user_id', user.id).single();\n            if (!buildingCheck) {\n                throw new Error('You do not have permission to add services to this building');\n            }\n        }\n        const { data, error } = await supabase.from('services').insert([\n            service\n        ]).select().single();\n        if (error) {\n            console.error('Error creating service:', error);\n            throw new Error(error.message);\n        }\n        return data;\n    } catch (error) {\n        console.error('Error in createService:', error);\n        throw error;\n    }\n};\nconst updateService = async (service)=>{\n    try {\n        // Get the current authenticated user\n        const { data: { user } } = await supabase.auth.getUser();\n        if (!user) {\n            throw new Error('You must be logged in to update a service');\n        }\n        // Get the service's building_id first\n        const { data: existingService } = await supabase.from('services').select('building_id').eq('id', service.id).single();\n        if (existingService && existingService.building_id) {\n            // Check if the building belongs to the user\n            const { data: buildingCheck } = await supabase.from('buildings').select('id').eq('id', existingService.building_id).eq('user_id', user.id).single();\n            if (!buildingCheck) {\n                throw new Error('You do not have permission to update this service');\n            }\n        }\n        const { data, error } = await supabase.from('services').update(service).eq('id', service.id).select().single();\n        if (error) {\n            console.error('Error updating service:', error);\n            throw new Error(error.message);\n        }\n        return data;\n    } catch (error) {\n        console.error('Error in updateService:', error);\n        throw error;\n    }\n};\nconst deleteService = async (id)=>{\n    try {\n        // Get the current authenticated user\n        const { data: { user } } = await supabase.auth.getUser();\n        if (!user) {\n            throw new Error('You must be logged in to delete a service');\n        }\n        // Get the service's building_id first\n        const { data: existingService } = await supabase.from('services').select('building_id').eq('id', id).single();\n        if (existingService && existingService.building_id) {\n            // Check if the building belongs to the user\n            const { data: buildingCheck } = await supabase.from('buildings').select('id').eq('id', existingService.building_id).eq('user_id', user.id).single();\n            if (!buildingCheck) {\n                throw new Error('You do not have permission to delete this service');\n            }\n        }\n        const { error } = await supabase.from('services').delete().eq('id', id);\n        if (error) {\n            console.error('Error deleting service:', error);\n            throw new Error(error.message);\n        }\n    } catch (error) {\n        console.error('Error in deleteService:', error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFxRDtBQUdyRCw2QkFBNkI7QUFDN0IsTUFBTUMsY0FBY0MsMENBQW9DLElBQUksQ0FBRTtBQUM5RCxNQUFNRyxjQUFjSCxrTkFBeUMsSUFBSSxDQUFFO0FBQ25FLE1BQU1LLFdBQVdQLG1FQUFZQSxDQUFDQyxhQUFhSTtBQUVwQyxNQUFNRyxjQUFjLE9BQU9DLFVBQW1CQztJQUNuRCxJQUFJO1FBQ0YsNEVBQTRFO1FBQzVFLDBFQUEwRTtRQUMxRSxJQUFJQSxhQUFhO1lBQ2YsSUFBSUMsUUFBUUosU0FDVEssSUFBSSxDQUFDLFlBQ0xDLE1BQU0sQ0FBQyxLQUNQQyxFQUFFLENBQUMsZUFBZUosYUFDbEJLLEtBQUssQ0FBQztZQUVULElBQUlOLFVBQVU7Z0JBQ1pFLFFBQVFBLE1BQU1HLEVBQUUsQ0FBQyxZQUFZTDtZQUMvQjtZQUVBLE1BQU0sRUFBRU8sSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNTjtZQUU5QixJQUFJTSxPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsNEJBQTRCQTtnQkFDMUMsTUFBTSxJQUFJRSxNQUFNRixNQUFNRyxPQUFPO1lBQy9CO1lBRUEsT0FBT0osUUFBUSxFQUFFO1FBQ25CO1FBRUEsd0RBQXdEO1FBQ3hELE1BQU0sRUFBRUEsTUFBTSxFQUFFSyxJQUFJLEVBQUUsRUFBRUosT0FBT0ssU0FBUyxFQUFFLEdBQUcsTUFBTWYsU0FBU2dCLElBQUksQ0FBQ0MsT0FBTztRQUV4RSxJQUFJRixXQUFXO1lBQ2JKLFFBQVFELEtBQUssQ0FBQyxlQUFlSztZQUM3QixNQUFNLElBQUlILE1BQU0sK0JBQWlELE9BQWxCRyxVQUFVRixPQUFPO1FBQ2xFO1FBRUEsSUFBSSxDQUFDQyxNQUFNO1lBQ1RILFFBQVFPLElBQUksQ0FBQztZQUNiLE9BQU8sRUFBRTtRQUNYO1FBRUEsdUNBQXVDO1FBQ3ZDLE1BQU0sRUFB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QyxhQUNMQyxNQUFNLENBQUMsTUFDUEMsRUFBRSxDQUFDLE1BQU1nQyxnQkFBZ0JwQyxXQUFXLEVBQ3BDSSxFQUFFLENBQUMsV0FBV08sS0FBS08sRUFBRSxFQUNyQk8sTUFBTTtZQUVULElBQUksQ0FBQ00sZUFBZTtnQkFDbEIsTUFBTSxJQUFJdEIsTUFBTTtZQUNsQjtRQUNGO1FBRUEsTUFBTSxFQUFFRixLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUNyQkssSUFBSSxDQUFDLFlBQ0xxQyxNQUFNLEdBQ05uQyxFQUFFLENBQUMsTUFBTWM7UUFFWixJQUFJWCxPQUFPO1lBQ1RDLFFBQVFELEtBQUssQ0FBQywyQkFBMkJBO1lBQ3pDLE1BQU0sSUFBSUUsTUFBTUYsTUFBTUcsT0FBTztRQUMvQjtJQUNGLEVBQUUsT0FBT0gsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsMkJBQTJCQTtRQUN6QyxNQUFNQTtJQUNSO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvZWxrd29oL0RvY3VtZW50cy9HaXRIdWIvbXlxcmNvZGUtaHViL2FwcC9zZXJ2aWNlcy9zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyBTZXJ2aWNlLCBDcmVhdGVTZXJ2aWNlSW5wdXQsIFVwZGF0ZVNlcnZpY2VJbnB1dCB9IGZyb20gJy4uL3R5cGVzL3NlcnZpY2UnO1xuXG4vLyBJbml0aWFsaXplIFN1cGFiYXNlIGNsaWVudFxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgfHwgJyc7XG5jb25zdCBzdXBhYmFzZUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIHx8ICcnO1xuY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5KTtcblxuZXhwb3J0IGNvbnN0IGdldFNlcnZpY2VzID0gYXN5bmMgKGNhdGVnb3J5Pzogc3RyaW5nLCBidWlsZGluZ19pZD86IHN0cmluZyk6IFByb21pc2U8U2VydmljZVtdPiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gR3Vlc3QgbW9kZSAtIGlmIGJ1aWxkaW5nX2lkIGlzIHByb3ZpZGVkLCB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIHVzZXIgYXV0aFxuICAgIC8vIFRoaXMgYWxsb3dzIGd1ZXN0cyB2aWV3aW5nIHRoZSBzZXJ2aWNlcyB0byBzZWUgaXRlbXMgd2l0aG91dCBsb2dnaW5nIGluXG4gICAgaWYgKGJ1aWxkaW5nX2lkKSB7XG4gICAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnc2VydmljZXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdidWlsZGluZ19pZCcsIGJ1aWxkaW5nX2lkKVxuICAgICAgICAub3JkZXIoJ25hbWUnKTtcbiAgICAgIFxuICAgICAgaWYgKGNhdGVnb3J5KSB7XG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ2NhdGVnb3J5JywgY2F0ZWdvcnkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNlcnZpY2VzOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YSB8fCBbXTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRtaW4gbW9kZSAtIGdldCB1c2VyJ3MgYnVpbGRpbmdzIGFuZCBmaWx0ZXIgc2VydmljZXNcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICBcbiAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBdXRoIGVycm9yOicsIHVzZXJFcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgY3VycmVudCB1c2VyOiAke3VzZXJFcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIGNvbnNvbGUud2FybignTm8gYXV0aGVudGljYXRlZCB1c2VyIGZvdW5kJyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIC8vIEdldCB0aGUgYnVpbGRpbmdzIG93bmVkIGJ5IHRoaXMgdXNlclxuICAgIGNvbnN0IHsgZGF0YTogdXNlckJ1aWxkaW5ncywgZXJyb3I6IGJ1aWxkaW5nc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2J1aWxkaW5ncycpXG4gICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKTtcbiAgICAgIFxuICAgIGlmIChidWlsZGluZ3NFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3IgZmV0Y2hpbmcgYnVpbGRpbmdzOicsIGJ1aWxkaW5nc0Vycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHVzZXIgYnVpbGRpbmdzOiAke2J1aWxkaW5nc0Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHVzZXJCdWlsZGluZ0lkcyA9IHVzZXJCdWlsZGluZ3M/Lm1hcChiID0+IGIuaWQpIHx8IFtdO1xuICAgIFxuICAgIGlmICh1c2VyQnVpbGRpbmdJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnc2VydmljZXMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuaW4oJ2J1aWxkaW5nX2lkJywgdXNlckJ1aWxkaW5nSWRzKVxuICAgICAgLm9yZGVyKCduYW1lJyk7XG4gICAgXG4gICAgaWYgKGNhdGVnb3J5KSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdjYXRlZ29yeScsIGNhdGVnb3J5KTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzZXJ2aWNlczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkYXRhIHx8IFtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldFNlcnZpY2VzOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFNlcnZpY2UgPSBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8U2VydmljZT4gPT4ge1xuICB0cnkge1xuICAgIC8vIEZpcnN0IGdldCB0aGUgc2VydmljZVxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnc2VydmljZXMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2lkJywgaWQpXG4gICAgICAuc2luZ2xlKCk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzZXJ2aWNlOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRm9yIGFkbWluIG9wZXJhdGlvbnMsIGNoZWNrIGlmIHRoaXMgYmVsb25ncyB0byB1c2VyJ3MgYnVpbGRpbmdcbiAgICBpZiAoaWQgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIGFkbWluIG1vZGUgKG5vdCB0aGUgb3JkZXIgcGFnZSlcbiAgICAgIGNvbnN0IGlzQWRtaW5Nb2RlID0gIXdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5zdGFydHNXaXRoKCcvb3JkZXInKTtcbiAgICAgIFxuICAgICAgaWYgKGlzQWRtaW5Nb2RlKSB7XG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB1c2VyXG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAvLyBWZXJpZnkgdGhpcyBzZXJ2aWNlIGJlbG9uZ3MgdG8gYSBidWlsZGluZyBvd25lZCBieSB0aGUgdXNlclxuICAgICAgICAgIGNvbnN0IHsgZGF0YTogYnVpbGRpbmdDaGVjayB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCdidWlsZGluZ3MnKVxuICAgICAgICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgICAgICAgLmVxKCdpZCcsIGRhdGEuYnVpbGRpbmdfaWQpXG4gICAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgaWYgKCFidWlsZGluZ0NoZWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGlzIHNlcnZpY2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0U2VydmljZTonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXJ2aWNlID0gYXN5bmMgKHNlcnZpY2U6IENyZWF0ZVNlcnZpY2VJbnB1dCk6IFByb21pc2U8U2VydmljZT4gPT4ge1xuICB0cnkge1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBhdXRoZW50aWNhdGVkIHVzZXJcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICBcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgYmUgbG9nZ2VkIGluIHRvIGNyZWF0ZSBhIHNlcnZpY2UnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGJ1aWxkaW5nIGJlbG9uZ3MgdG8gdGhlIHVzZXJcbiAgICBpZiAoc2VydmljZS5idWlsZGluZ19pZCkge1xuICAgICAgY29uc3QgeyBkYXRhOiBidWlsZGluZ0NoZWNrIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnYnVpbGRpbmdzJylcbiAgICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgICAuZXEoJ2lkJywgc2VydmljZS5idWlsZGluZ19pZClcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcbiAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICBcbiAgICAgIGlmICghYnVpbGRpbmdDaGVjaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFkZCBzZXJ2aWNlcyB0byB0aGlzIGJ1aWxkaW5nJyk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnc2VydmljZXMnKVxuICAgICAgLmluc2VydChbc2VydmljZV0pXG4gICAgICAuc2VsZWN0KClcbiAgICAgIC5zaW5nbGUoKTtcbiAgICBcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHNlcnZpY2U6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBjcmVhdGVTZXJ2aWNlOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZVNlcnZpY2UgPSBhc3luYyAoc2VydmljZTogVXBkYXRlU2VydmljZUlucHV0KTogUHJvbWlzZTxTZXJ2aWNlPiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0ZWQgdXNlclxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgIFxuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBiZSBsb2dnZWQgaW4gdG8gdXBkYXRlIGEgc2VydmljZScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgdGhlIHNlcnZpY2UncyBidWlsZGluZ19pZCBmaXJzdFxuICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdTZXJ2aWNlIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3NlcnZpY2VzJylcbiAgICAgIC5zZWxlY3QoJ2J1aWxkaW5nX2lkJylcbiAgICAgIC5lcSgnaWQnLCBzZXJ2aWNlLmlkKVxuICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgaWYgKGV4aXN0aW5nU2VydmljZSAmJiBleGlzdGluZ1NlcnZpY2UuYnVpbGRpbmdfaWQpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBidWlsZGluZyBiZWxvbmdzIHRvIHRoZSB1c2VyXG4gICAgICBjb25zdCB7IGRhdGE6IGJ1aWxkaW5nQ2hlY2sgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdidWlsZGluZ3MnKVxuICAgICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAgIC5lcSgnaWQnLCBleGlzdGluZ1NlcnZpY2UuYnVpbGRpbmdfaWQpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgXG4gICAgICBpZiAoIWJ1aWxkaW5nQ2hlY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byB1cGRhdGUgdGhpcyBzZXJ2aWNlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnc2VydmljZXMnKVxuICAgICAgLnVwZGF0ZShzZXJ2aWNlKVxuICAgICAgLmVxKCdpZCcsIHNlcnZpY2UuaWQpXG4gICAgICAuc2VsZWN0KClcbiAgICAgIC5zaW5nbGUoKTtcbiAgICBcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHNlcnZpY2U6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiB1cGRhdGVTZXJ2aWNlOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVNlcnZpY2UgPSBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICB0cnkge1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBhdXRoZW50aWNhdGVkIHVzZXJcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICBcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgYmUgbG9nZ2VkIGluIHRvIGRlbGV0ZSBhIHNlcnZpY2UnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IHRoZSBzZXJ2aWNlJ3MgYnVpbGRpbmdfaWQgZmlyc3RcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nU2VydmljZSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdzZXJ2aWNlcycpXG4gICAgICAuc2VsZWN0KCdidWlsZGluZ19pZCcpXG4gICAgICAuZXEoJ2lkJywgaWQpXG4gICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICBpZiAoZXhpc3RpbmdTZXJ2aWNlICYmIGV4aXN0aW5nU2VydmljZS5idWlsZGluZ19pZCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJ1aWxkaW5nIGJlbG9uZ3MgdG8gdGhlIHVzZXJcbiAgICAgIGNvbnN0IHsgZGF0YTogYnVpbGRpbmdDaGVjayB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2J1aWxkaW5ncycpXG4gICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgLmVxKCdpZCcsIGV4aXN0aW5nU2VydmljZS5idWlsZGluZ19pZClcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcbiAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICBcbiAgICAgIGlmICghYnVpbGRpbmdDaGVjaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGRlbGV0ZSB0aGlzIHNlcnZpY2UnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdzZXJ2aWNlcycpXG4gICAgICAuZGVsZXRlKClcbiAgICAgIC5lcSgnaWQnLCBpZCk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBzZXJ2aWNlOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZGVsZXRlU2VydmljZTonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07ICJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJzdXBhYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZUtleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwic3VwYWJhc2UiLCJnZXRTZXJ2aWNlcyIsImNhdGVnb3J5IiwiYnVpbGRpbmdfaWQiLCJxdWVyeSIsImZyb20iLCJzZWxlY3QiLCJlcSIsIm9yZGVyIiwiZGF0YSIsImVycm9yIiwiY29uc29sZSIsIkVycm9yIiwibWVzc2FnZSIsInVzZXIiLCJ1c2VyRXJyb3IiLCJhdXRoIiwiZ2V0VXNlciIsIndhcm4iLCJ1c2VyQnVpbGRpbmdzIiwiYnVpbGRpbmdzRXJyb3IiLCJpZCIsInVzZXJCdWlsZGluZ0lkcyIsIm1hcCIsImIiLCJsZW5ndGgiLCJpbiIsImdldFNlcnZpY2UiLCJzaW5nbGUiLCJpc0FkbWluTW9kZSIsIndpbmRvdyIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJzdGFydHNXaXRoIiwiYnVpbGRpbmdDaGVjayIsImNyZWF0ZVNlcnZpY2UiLCJzZXJ2aWNlIiwiaW5zZXJ0IiwidXBkYXRlU2VydmljZSIsImV4aXN0aW5nU2VydmljZSIsInVwZGF0ZSIsImRlbGV0ZVNlcnZpY2UiLCJkZWxldGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/service.ts\n"));

/***/ })

});