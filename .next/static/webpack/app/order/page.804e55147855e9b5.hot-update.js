"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/order/page",{

/***/ "(app-pages-browser)/./app/services/order.ts":
/*!*******************************!*\
  !*** ./app/services/order.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOrder: () => (/* binding */ createOrder),\n/* harmony export */   deleteOrder: () => (/* binding */ deleteOrder),\n/* harmony export */   getOrder: () => (/* binding */ getOrder),\n/* harmony export */   getOrders: () => (/* binding */ getOrders),\n/* harmony export */   updateOrderStatus: () => (/* binding */ updateOrderStatus)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabaseUrl = \"https://pslapwodbwhedywmlfmk.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBzbGFwd29kYndoZWR5d21sZm1rIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA1NTQ4NzgsImV4cCI6MjA1NjEzMDg3OH0.YXR7RN1ELBO8ywDv_tXpioTFJrpNXr9UtDLhxzgcHmU\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\nasync function getOrders(filters) {\n    try {\n        // Get the current authenticated user\n        const { data: { user }, error: userError } = await supabase.auth.getUser();\n        if (userError) {\n            console.error('Auth error:', userError);\n            throw new Error(\"Failed to get current user: \".concat(userError.message));\n        }\n        if (!user) {\n            console.warn('No authenticated user found');\n            return [];\n        }\n        // First, get the list of buildings owned by this user\n        const { data: userBuildings, error: buildingsError } = await supabase.from('buildings').select('id').eq('user_id', user.id);\n        if (buildingsError) {\n            console.error('Supabase error fetching buildings:', buildingsError);\n            throw new Error(\"Failed to fetch user buildings: \".concat(buildingsError.message));\n        }\n        const userBuildingIds = (userBuildings === null || userBuildings === void 0 ? void 0 : userBuildings.map((b)=>b.id)) || [];\n        if (userBuildingIds.length === 0) {\n            return [];\n        }\n        let query = supabase.from('orders').select(\"\\n        *,\\n        order_items:order_items(*)\\n      \").in('building_id', userBuildingIds).order('created_at', {\n            ascending: false\n        });\n        if (filters) {\n            if (filters.unit_id) {\n                query = query.eq('unit_id', filters.unit_id);\n            }\n            if (filters.building_id) {\n                // Verify the building belongs to the user before filtering\n                if (userBuildingIds.includes(filters.building_id)) {\n                    query = query.eq('building_id', filters.building_id);\n                } else {\n                    console.warn(\"Building \".concat(filters.building_id, \" does not belong to user \").concat(user.id));\n                    return [];\n                }\n            }\n            if (filters.status) {\n                query = query.eq('status', filters.status);\n            }\n        }\n        const { data, error } = await query;\n        if (error) {\n            console.error('Supabase error:', error);\n            throw new Error(\"Failed to fetch orders: \".concat(error.message));\n        }\n        if (!data) {\n            return [];\n        }\n        return data;\n    } catch (error) {\n        console.error('Error in getOrders:', error);\n        throw error;\n    }\n}\nasync function getOrder(id) {\n    try {\n        // Get the current authenticated user\n        const { data: { user } } = await supabase.auth.getUser();\n        if (!user) {\n            throw new Error('You must be logged in to view order details');\n        }\n        // Get the user's buildings\n        const { data: userBuildings } = await supabase.from('buildings').select('id').eq('user_id', user.id);\n        const userBuildingIds = (userBuildings === null || userBuildings === void 0 ? void 0 : userBuildings.map((b)=>b.id)) || [];\n        const { data, error } = await supabase.from('orders').select(\"\\n        *,\\n        order_items:order_items(*)\\n      \").eq('id', id).single();\n        if (error) {\n            return null;\n        }\n        if (!data) {\n            return null;\n        }\n        // Check if this order belongs to one of the user's buildings\n        if (!userBuildingIds.includes(data.building_id)) {\n            console.warn(\"Order \".concat(id, \" does not belong to any building owned by user \").concat(user.id));\n            return null;\n        }\n        return data;\n    } catch (error) {\n        console.error('Error in getOrder:', error);\n        throw error;\n    }\n}\nasync function createOrder(orderInput) {\n    try {\n        // Calculate total amount based on prices and quantities\n        const totalAmount = orderInput.items.reduce((sum, item)=>sum + item.price * item.quantity, 0);\n        // Verify the building exists\n        const { data: buildingCheck } = await supabase.from('buildings').select('id').eq('id', orderInput.building_id).single();\n        if (!buildingCheck) {\n            throw new Error(\"Building with ID \".concat(orderInput.building_id, \" does not exist\"));\n        }\n        // Create the order first\n        const { data: orderData, error: orderError } = await supabase.from('orders').insert([\n            {\n                unit_id: orderInput.unit_id,\n                unit_number: orderInput.unit_number,\n                building_id: orderInput.building_id,\n                building_name: orderInput.building_name,\n                status: 'pending',\n                total_amount: totalAmount,\n                notes: orderInput.notes || ''\n            }\n        ]).select().single();\n        if (orderError) {\n            console.error('Error creating order:', orderError);\n            throw orderError;\n        }\n        if (!orderData) {\n            throw new Error('No data returned after creating order');\n        }\n        // Now create all the order items\n        const orderItems = orderInput.items.map((item)=>({\n                order_id: orderData.id,\n                item_type: item.item_type,\n                item_id: item.item_id,\n                name: item.name,\n                price: item.price,\n                quantity: item.quantity,\n                notes: item.notes || ''\n            }));\n        const { error: itemsError } = await supabase.from('order_items').insert(orderItems);\n        if (itemsError) {\n            console.error('Error creating order items:', itemsError);\n            // If there's an error creating order items, delete the order to maintain consistency\n            const { error: deleteError } = await supabase.from('orders').delete().eq('id', orderData.id);\n            if (deleteError) {\n                console.error('Error deleting order after failed items creation:', deleteError);\n            }\n            throw itemsError;\n        }\n        // Finally, fetch the complete order with items\n        return await getOrder(orderData.id);\n    } catch (error) {\n        console.error('Error in createOrder:', error);\n        throw error;\n    }\n}\nasync function updateOrderStatus(updateInput) {\n    try {\n        // Get the current authenticated user\n        const { data: { user } } = await supabase.auth.getUser();\n        if (!user) {\n            throw new Error('You must be logged in to update an order');\n        }\n        // Get the user's buildings\n        const { data: userBuildings } = await supabase.from('buildings').select('id').eq('user_id', user.id);\n        const userBuildingIds = (userBuildings === null || userBuildings === void 0 ? void 0 : userBuildings.map((b)=>b.id)) || [];\n        // First check if the order belongs to one of the user's buildings\n        const { data: orderData } = await supabase.from('orders').select('building_id').eq('id', updateInput.id).single();\n        if (!orderData || !userBuildingIds.includes(orderData.building_id)) {\n            throw new Error('You do not have permission to update this order');\n        }\n        const { data, error } = await supabase.from('orders').update({\n            status: updateInput.status,\n            updated_at: new Date().toISOString()\n        }).eq('id', updateInput.id).select().single();\n        if (error) {\n            throw error;\n        }\n        return await getOrder(updateInput.id);\n    } catch (error) {\n        console.error('Error in updateOrderStatus:', error);\n        throw error;\n    }\n}\nasync function deleteOrder(id) {\n    try {\n        // Get the current authenticated user\n        const { data: { user } } = await supabase.auth.getUser();\n        if (!user) {\n            throw new Error('You must be logged in to delete an order');\n        }\n        // Get the user's buildings\n        const { data: userBuildings } = await supabase.from('buildings').select('id').eq('user_id', user.id);\n        const userBuildingIds = (userBuildings === null || userBuildings === void 0 ? void 0 : userBuildings.map((b)=>b.id)) || [];\n        // First check if the order belongs to one of the user's buildings\n        const { data: orderData } = await supabase.from('orders').select('building_id').eq('id', id).single();\n        if (!orderData || !userBuildingIds.includes(orderData.building_id)) {\n            throw new Error('You do not have permission to delete this order');\n        }\n        // Delete the order - the cascade constraint will handle deleting associated items\n        const { error } = await supabase.from('orders').delete().eq('id', id);\n        if (error) {\n            throw error;\n        }\n    } catch (error) {\n        console.error('Error in deleteOrder:', error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9vcmRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBcUQ7QUFHckQsTUFBTUMsY0FBY0MsMENBQW9DO0FBQ3hELE1BQU1HLGtCQUFrQkgsa05BQXlDO0FBQ2pFLE1BQU1LLFdBQVdQLG1FQUFZQSxDQUFDQyxhQUFhSTtBQUVwQyxlQUFlRyxVQUFVQyxPQUkvQjtJQUNDLElBQUk7UUFDRixxQ0FBcUM7UUFDckMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRSxFQUFFQyxPQUFPQyxTQUFTLEVBQUUsR0FBRyxNQUFNTixTQUFTTyxJQUFJLENBQUNDLE9BQU87UUFFeEUsSUFBSUYsV0FBVztZQUNiRyxRQUFRSixLQUFLLENBQUMsZUFBZUM7WUFDN0IsTUFBTSxJQUFJSSxNQUFNLCtCQUFpRCxPQUFsQkosVUFBVUssT0FBTztRQUNsRTtRQUVBLElBQUksQ0FBQ1AsTUFBTTtZQUNUSyxRQUFRRyxJQUFJLENBQUM7WUFDYixPQUFPLEVBQUU7UUFDWDtRQUVBLHNEQUFzRDtRQUN0RCxNQUFNLEVBQUVULE1BQU1VLGFBQWEsRUFBRVIsT0FBT1MsY0FBYyxFQUFFLEdBQUcsTUFBTWQsU0FDMURlLElBQUksQ0FBQyxhQUNMQyxNQUFNLENBQUMsTUFDUEMsRUFBRSxDQUFDLFdBQVdiLEtBQUtjLEVBQUU7UUFFeEIsSUFBSUosZ0JBQWdCO1lBQ2xCTCxRQUFRSixLQUFLLENBQUMsc0NBQXNDUztZQUNwRCxNQUFNLElBQUlKLE1BQU0sbUNBQTBELE9BQXZCSSxlQUFlSCxPQUFPO1FBQzNFO1FBRUEsTUFBTVEsa0JBQWtCTixDQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWVPLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUgsRUFBRSxNQUFLLEVBQUU7UUFFM0QsSUFBSUMsZ0JBQWdCRyxNQUFNLEtBQUssR0FBRztZQUNoQyxPQUFPLEVBQUU7UUFDWDtRQUVBLElBQUlDLFFBQVF2QixTQUNUZSxJQUFJLENB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UyxFQUFFLEdBQUcsTUFBTTNDLFNBQy9CZSxJQUFJLENBQUMsVUFDTEMsTUFBTSxDQUFDLGVBQ1BDLEVBQUUsQ0FBQyxNQUFNQyxJQUNUYyxNQUFNO1FBRVQsSUFBSSxDQUFDVyxhQUFhLENBQUN4QixnQkFBZ0JVLFFBQVEsQ0FBQ2MsVUFBVWYsV0FBVyxHQUFHO1lBQ2xFLE1BQU0sSUFBSWxCLE1BQU07UUFDbEI7UUFFQSxrRkFBa0Y7UUFDbEYsTUFBTSxFQUFFTCxLQUFLLEVBQUUsR0FBRyxNQUFNTCxTQUNyQmUsSUFBSSxDQUFDLFVBQ0wwQyxNQUFNLEdBQ054QyxFQUFFLENBQUMsTUFBTUM7UUFFWixJQUFJYixPQUFPO1lBQ1QsTUFBTUE7UUFDUjtJQUNGLEVBQUUsT0FBT0EsT0FBTztRQUNkSSxRQUFRSixLQUFLLENBQUMseUJBQXlCQTtRQUN2QyxNQUFNQTtJQUNSO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb2Vsa3dvaC9Eb2N1bWVudHMvR2l0SHViL215cXJjb2RlLWh1Yi9hcHAvc2VydmljZXMvb3JkZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcbmltcG9ydCB7IE9yZGVyLCBDcmVhdGVPcmRlcklucHV0LCBVcGRhdGVPcmRlclN0YXR1c0lucHV0LCBPcmRlckl0ZW0gfSBmcm9tICcuLi90eXBlcy9vcmRlcic7XG5cbmNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMITtcbmNvbnN0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZITtcbmNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXkpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0T3JkZXJzKGZpbHRlcnM/OiB7XG4gIHVuaXRfaWQ/OiBzdHJpbmc7XG4gIGJ1aWxkaW5nX2lkPzogc3RyaW5nO1xuICBzdGF0dXM/OiBzdHJpbmc7XG59KTogUHJvbWlzZTxPcmRlcltdPiB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0ZWQgdXNlclxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgIFxuICAgIGlmICh1c2VyRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dGggZXJyb3I6JywgdXNlckVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBjdXJyZW50IHVzZXI6ICR7dXNlckVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdXNlcikge1xuICAgICAgY29uc29sZS53YXJuKCdObyBhdXRoZW50aWNhdGVkIHVzZXIgZm91bmQnKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmlyc3QsIGdldCB0aGUgbGlzdCBvZiBidWlsZGluZ3Mgb3duZWQgYnkgdGhpcyB1c2VyXG4gICAgY29uc3QgeyBkYXRhOiB1c2VyQnVpbGRpbmdzLCBlcnJvcjogYnVpbGRpbmdzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYnVpbGRpbmdzJylcbiAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpO1xuICAgICAgXG4gICAgaWYgKGJ1aWxkaW5nc0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvciBmZXRjaGluZyBidWlsZGluZ3M6JywgYnVpbGRpbmdzRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggdXNlciBidWlsZGluZ3M6ICR7YnVpbGRpbmdzRXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdXNlckJ1aWxkaW5nSWRzID0gdXNlckJ1aWxkaW5ncz8ubWFwKGIgPT4gYi5pZCkgfHwgW107XG4gICAgXG4gICAgaWYgKHVzZXJCdWlsZGluZ0lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdvcmRlcnMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIG9yZGVyX2l0ZW1zOm9yZGVyX2l0ZW1zKCopXG4gICAgICBgKVxuICAgICAgLmluKCdidWlsZGluZ19pZCcsIHVzZXJCdWlsZGluZ0lkcylcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICBcbiAgICBpZiAoZmlsdGVycykge1xuICAgICAgaWYgKGZpbHRlcnMudW5pdF9pZCkge1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCd1bml0X2lkJywgZmlsdGVycy51bml0X2lkKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXJzLmJ1aWxkaW5nX2lkKSB7XG4gICAgICAgIC8vIFZlcmlmeSB0aGUgYnVpbGRpbmcgYmVsb25ncyB0byB0aGUgdXNlciBiZWZvcmUgZmlsdGVyaW5nXG4gICAgICAgIGlmICh1c2VyQnVpbGRpbmdJZHMuaW5jbHVkZXMoZmlsdGVycy5idWlsZGluZ19pZCkpIHtcbiAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdidWlsZGluZ19pZCcsIGZpbHRlcnMuYnVpbGRpbmdfaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQnVpbGRpbmcgJHtmaWx0ZXJzLmJ1aWxkaW5nX2lkfSBkb2VzIG5vdCBiZWxvbmcgdG8gdXNlciAke3VzZXIuaWR9YCk7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVycy5zdGF0dXMpIHtcbiAgICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnc3RhdHVzJywgZmlsdGVycy5zdGF0dXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggb3JkZXJzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEgYXMgT3JkZXJbXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRPcmRlcnM6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPcmRlcihpZDogc3RyaW5nKTogUHJvbWlzZTxPcmRlciB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRlZCB1c2VyXG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgXG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGJlIGxvZ2dlZCBpbiB0byB2aWV3IG9yZGVyIGRldGFpbHMnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IHRoZSB1c2VyJ3MgYnVpbGRpbmdzXG4gICAgY29uc3QgeyBkYXRhOiB1c2VyQnVpbGRpbmdzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2J1aWxkaW5ncycpXG4gICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKTtcbiAgICAgIFxuICAgIGNvbnN0IHVzZXJCdWlsZGluZ0lkcyA9IHVzZXJCdWlsZGluZ3M/Lm1hcChiID0+IGIuaWQpIHx8IFtdO1xuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnb3JkZXJzJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICBvcmRlcl9pdGVtczpvcmRlcl9pdGVtcygqKVxuICAgICAgYClcbiAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBvcmRlciBiZWxvbmdzIHRvIG9uZSBvZiB0aGUgdXNlcidzIGJ1aWxkaW5nc1xuICAgIGlmICghdXNlckJ1aWxkaW5nSWRzLmluY2x1ZGVzKGRhdGEuYnVpbGRpbmdfaWQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE9yZGVyICR7aWR9IGRvZXMgbm90IGJlbG9uZyB0byBhbnkgYnVpbGRpbmcgb3duZWQgYnkgdXNlciAke3VzZXIuaWR9YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSBhcyBPcmRlcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRPcmRlcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU9yZGVyKG9yZGVySW5wdXQ6IENyZWF0ZU9yZGVySW5wdXQpOiBQcm9taXNlPE9yZGVyPiB7XG4gIHRyeSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRvdGFsIGFtb3VudCBiYXNlZCBvbiBwcmljZXMgYW5kIHF1YW50aXRpZXNcbiAgICBjb25zdCB0b3RhbEFtb3VudCA9IG9yZGVySW5wdXQuaXRlbXMucmVkdWNlKFxuICAgICAgKHN1bSwgaXRlbSkgPT4gc3VtICsgKGl0ZW0ucHJpY2UgKiBpdGVtLnF1YW50aXR5KSwgXG4gICAgICAwXG4gICAgKTtcbiAgICBcbiAgICAvLyBWZXJpZnkgdGhlIGJ1aWxkaW5nIGV4aXN0c1xuICAgIGNvbnN0IHsgZGF0YTogYnVpbGRpbmdDaGVjayB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdidWlsZGluZ3MnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmVxKCdpZCcsIG9yZGVySW5wdXQuYnVpbGRpbmdfaWQpXG4gICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICBpZiAoIWJ1aWxkaW5nQ2hlY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQnVpbGRpbmcgd2l0aCBJRCAke29yZGVySW5wdXQuYnVpbGRpbmdfaWR9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHRoZSBvcmRlciBmaXJzdFxuICAgIGNvbnN0IHsgZGF0YTogb3JkZXJEYXRhLCBlcnJvcjogb3JkZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdvcmRlcnMnKVxuICAgICAgLmluc2VydChbe1xuICAgICAgICB1bml0X2lkOiBvcmRlcklucHV0LnVuaXRfaWQsXG4gICAgICAgIHVuaXRfbnVtYmVyOiBvcmRlcklucHV0LnVuaXRfbnVtYmVyLFxuICAgICAgICBidWlsZGluZ19pZDogb3JkZXJJbnB1dC5idWlsZGluZ19pZCxcbiAgICAgICAgYnVpbGRpbmdfbmFtZTogb3JkZXJJbnB1dC5idWlsZGluZ19uYW1lLFxuICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgdG90YWxfYW1vdW50OiB0b3RhbEFtb3VudCxcbiAgICAgICAgbm90ZXM6IG9yZGVySW5wdXQubm90ZXMgfHwgJydcbiAgICAgIH1dKVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAob3JkZXJFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgb3JkZXI6Jywgb3JkZXJFcnJvcik7XG4gICAgICB0aHJvdyBvcmRlckVycm9yO1xuICAgIH1cblxuICAgIGlmICghb3JkZXJEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGEgcmV0dXJuZWQgYWZ0ZXIgY3JlYXRpbmcgb3JkZXInKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgY3JlYXRlIGFsbCB0aGUgb3JkZXIgaXRlbXNcbiAgICBjb25zdCBvcmRlckl0ZW1zID0gb3JkZXJJbnB1dC5pdGVtcy5tYXAoaXRlbSA9PiAoe1xuICAgICAgb3JkZXJfaWQ6IG9yZGVyRGF0YS5pZCxcbiAgICAgIGl0ZW1fdHlwZTogaXRlbS5pdGVtX3R5cGUsXG4gICAgICBpdGVtX2lkOiBpdGVtLml0ZW1faWQsXG4gICAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgICBwcmljZTogaXRlbS5wcmljZSxcbiAgICAgIHF1YW50aXR5OiBpdGVtLnF1YW50aXR5LFxuICAgICAgbm90ZXM6IGl0ZW0ubm90ZXMgfHwgJydcbiAgICB9KSk7XG5cbiAgICBjb25zdCB7IGVycm9yOiBpdGVtc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ29yZGVyX2l0ZW1zJylcbiAgICAgIC5pbnNlcnQob3JkZXJJdGVtcyk7XG5cbiAgICBpZiAoaXRlbXNFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgb3JkZXIgaXRlbXM6JywgaXRlbXNFcnJvcik7XG4gICAgICBcbiAgICAgIC8vIElmIHRoZXJlJ3MgYW4gZXJyb3IgY3JlYXRpbmcgb3JkZXIgaXRlbXMsIGRlbGV0ZSB0aGUgb3JkZXIgdG8gbWFpbnRhaW4gY29uc2lzdGVuY3lcbiAgICAgIGNvbnN0IHsgZXJyb3I6IGRlbGV0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnb3JkZXJzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgnaWQnLCBvcmRlckRhdGEuaWQpO1xuICAgICAgXG4gICAgICBpZiAoZGVsZXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgb3JkZXIgYWZ0ZXIgZmFpbGVkIGl0ZW1zIGNyZWF0aW9uOicsIGRlbGV0ZUVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgaXRlbXNFcnJvcjtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGx5LCBmZXRjaCB0aGUgY29tcGxldGUgb3JkZXIgd2l0aCBpdGVtc1xuICAgIHJldHVybiBhd2FpdCBnZXRPcmRlcihvcmRlckRhdGEuaWQpIGFzIE9yZGVyO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGNyZWF0ZU9yZGVyOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlT3JkZXJTdGF0dXModXBkYXRlSW5wdXQ6IFVwZGF0ZU9yZGVyU3RhdHVzSW5wdXQpOiBQcm9taXNlPE9yZGVyPiB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0ZWQgdXNlclxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgIFxuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBiZSBsb2dnZWQgaW4gdG8gdXBkYXRlIGFuIG9yZGVyJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEdldCB0aGUgdXNlcidzIGJ1aWxkaW5nc1xuICAgIGNvbnN0IHsgZGF0YTogdXNlckJ1aWxkaW5ncyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdidWlsZGluZ3MnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZCk7XG4gICAgICBcbiAgICBjb25zdCB1c2VyQnVpbGRpbmdJZHMgPSB1c2VyQnVpbGRpbmdzPy5tYXAoYiA9PiBiLmlkKSB8fCBbXTtcbiAgICBcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgb3JkZXIgYmVsb25ncyB0byBvbmUgb2YgdGhlIHVzZXIncyBidWlsZGluZ3NcbiAgICBjb25zdCB7IGRhdGE6IG9yZGVyRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdvcmRlcnMnKVxuICAgICAgLnNlbGVjdCgnYnVpbGRpbmdfaWQnKVxuICAgICAgLmVxKCdpZCcsIHVwZGF0ZUlucHV0LmlkKVxuICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgaWYgKCFvcmRlckRhdGEgfHwgIXVzZXJCdWlsZGluZ0lkcy5pbmNsdWRlcyhvcmRlckRhdGEuYnVpbGRpbmdfaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHVwZGF0ZSB0aGlzIG9yZGVyJyk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnb3JkZXJzJylcbiAgICAgIC51cGRhdGUoeyBcbiAgICAgICAgc3RhdHVzOiB1cGRhdGVJbnB1dC5zdGF0dXMsXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSlcbiAgICAgIC5lcSgnaWQnLCB1cGRhdGVJbnB1dC5pZClcbiAgICAgIC5zZWxlY3QoKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgZ2V0T3JkZXIodXBkYXRlSW5wdXQuaWQpIGFzIE9yZGVyO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHVwZGF0ZU9yZGVyU3RhdHVzOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlT3JkZXIoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBhdXRoZW50aWNhdGVkIHVzZXJcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICBcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgYmUgbG9nZ2VkIGluIHRvIGRlbGV0ZSBhbiBvcmRlcicpO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgdGhlIHVzZXIncyBidWlsZGluZ3NcbiAgICBjb25zdCB7IGRhdGE6IHVzZXJCdWlsZGluZ3MgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYnVpbGRpbmdzJylcbiAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpO1xuICAgICAgXG4gICAgY29uc3QgdXNlckJ1aWxkaW5nSWRzID0gdXNlckJ1aWxkaW5ncz8ubWFwKGIgPT4gYi5pZCkgfHwgW107XG4gICAgXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIG9yZGVyIGJlbG9uZ3MgdG8gb25lIG9mIHRoZSB1c2VyJ3MgYnVpbGRpbmdzXG4gICAgY29uc3QgeyBkYXRhOiBvcmRlckRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnb3JkZXJzJylcbiAgICAgIC5zZWxlY3QoJ2J1aWxkaW5nX2lkJylcbiAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgIC5zaW5nbGUoKTtcbiAgICAgIFxuICAgIGlmICghb3JkZXJEYXRhIHx8ICF1c2VyQnVpbGRpbmdJZHMuaW5jbHVkZXMob3JkZXJEYXRhLmJ1aWxkaW5nX2lkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBkZWxldGUgdGhpcyBvcmRlcicpO1xuICAgIH1cbiAgICBcbiAgICAvLyBEZWxldGUgdGhlIG9yZGVyIC0gdGhlIGNhc2NhZGUgY29uc3RyYWludCB3aWxsIGhhbmRsZSBkZWxldGluZyBhc3NvY2lhdGVkIGl0ZW1zXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdvcmRlcnMnKVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAuZXEoJ2lkJywgaWQpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZGVsZXRlT3JkZXI6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59ICJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJzdXBhYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZUFub25LZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsInN1cGFiYXNlIiwiZ2V0T3JkZXJzIiwiZmlsdGVycyIsImRhdGEiLCJ1c2VyIiwiZXJyb3IiLCJ1c2VyRXJyb3IiLCJhdXRoIiwiZ2V0VXNlciIsImNvbnNvbGUiLCJFcnJvciIsIm1lc3NhZ2UiLCJ3YXJuIiwidXNlckJ1aWxkaW5ncyIsImJ1aWxkaW5nc0Vycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwiaWQiLCJ1c2VyQnVpbGRpbmdJZHMiLCJtYXAiLCJiIiwibGVuZ3RoIiwicXVlcnkiLCJpbiIsIm9yZGVyIiwiYXNjZW5kaW5nIiwidW5pdF9pZCIsImJ1aWxkaW5nX2lkIiwiaW5jbHVkZXMiLCJzdGF0dXMiLCJnZXRPcmRlciIsInNpbmdsZSIsImNyZWF0ZU9yZGVyIiwib3JkZXJJbnB1dCIsInRvdGFsQW1vdW50IiwiaXRlbXMiLCJyZWR1Y2UiLCJzdW0iLCJpdGVtIiwicHJpY2UiLCJxdWFudGl0eSIsImJ1aWxkaW5nQ2hlY2siLCJvcmRlckRhdGEiLCJvcmRlckVycm9yIiwiaW5zZXJ0IiwidW5pdF9udW1iZXIiLCJidWlsZGluZ19uYW1lIiwidG90YWxfYW1vdW50Iiwibm90ZXMiLCJvcmRlckl0ZW1zIiwib3JkZXJfaWQiLCJpdGVtX3R5cGUiLCJpdGVtX2lkIiwibmFtZSIsIml0ZW1zRXJyb3IiLCJkZWxldGVFcnJvciIsImRlbGV0ZSIsInVwZGF0ZU9yZGVyU3RhdHVzIiwidXBkYXRlSW5wdXQiLCJ1cGRhdGUiLCJ1cGRhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZGVsZXRlT3JkZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/order.ts\n"));

/***/ })

});