"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/orders/page",{

/***/ "(app-pages-browser)/./app/services/order.ts":
/*!*******************************!*\
  !*** ./app/services/order.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOrder: () => (/* binding */ createOrder),\n/* harmony export */   deleteOrder: () => (/* binding */ deleteOrder),\n/* harmony export */   getOrder: () => (/* binding */ getOrder),\n/* harmony export */   getOrders: () => (/* binding */ getOrders),\n/* harmony export */   updateOrderStatus: () => (/* binding */ updateOrderStatus)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabaseUrl = \"https://pslapwodbwhedywmlfmk.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBzbGFwd29kYndoZWR5d21sZm1rIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA1NTQ4NzgsImV4cCI6MjA1NjEzMDg3OH0.YXR7RN1ELBO8ywDv_tXpioTFJrpNXr9UtDLhxzgcHmU\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\nasync function getOrders(filters) {\n    try {\n        // Get the current authenticated user\n        const { data: { user }, error: userError } = await supabase.auth.getUser();\n        if (userError) {\n            console.error('Auth error:', userError);\n            throw new Error(\"Failed to get current user: \".concat(userError.message));\n        }\n        if (!user) {\n            console.warn('No authenticated user found');\n            return [];\n        }\n        // First, get the list of buildings owned by this user\n        const { data: userBuildings, error: buildingsError } = await supabase.from('buildings').select('id').eq('user_id', user.id);\n        if (buildingsError) {\n            console.error('Supabase error fetching buildings:', buildingsError);\n            throw new Error(\"Failed to fetch user buildings: \".concat(buildingsError.message));\n        }\n        const userBuildingIds = (userBuildings === null || userBuildings === void 0 ? void 0 : userBuildings.map((b)=>b.id)) || [];\n        if (userBuildingIds.length === 0) {\n            return [];\n        }\n        let query = supabase.from('orders').select(\"\\n        *,\\n        order_items:order_items(*)\\n      \").in('building_id', userBuildingIds).order('created_at', {\n            ascending: false\n        });\n        if (filters) {\n            if (filters.unit_id) {\n                query = query.eq('unit_id', filters.unit_id);\n            }\n            if (filters.building_id) {\n                // Verify the building belongs to the user before filtering\n                if (userBuildingIds.includes(filters.building_id)) {\n                    query = query.eq('building_id', filters.building_id);\n                } else {\n                    console.warn(\"Building \".concat(filters.building_id, \" does not belong to user \").concat(user.id));\n                    return [];\n                }\n            }\n            if (filters.status) {\n                query = query.eq('status', filters.status);\n            }\n        }\n        const { data, error } = await query;\n        if (error) {\n            console.error('Supabase error:', error);\n            throw new Error(\"Failed to fetch orders: \".concat(error.message));\n        }\n        if (!data) {\n            return [];\n        }\n        return data;\n    } catch (error) {\n        console.error('Error in getOrders:', error);\n        throw error;\n    }\n}\nasync function getOrder(id) {\n    try {\n        // Get the current authenticated user\n        const { data: { user } } = await supabase.auth.getUser();\n        if (!user) {\n            throw new Error('You must be logged in to view order details');\n        }\n        // Get the user's buildings\n        const { data: userBuildings } = await supabase.from('buildings').select('id').eq('user_id', user.id);\n        const userBuildingIds = (userBuildings === null || userBuildings === void 0 ? void 0 : userBuildings.map((b)=>b.id)) || [];\n        const { data, error } = await supabase.from('orders').select(\"\\n        *,\\n        order_items:order_items(*)\\n      \").eq('id', id).single();\n        if (error) {\n            return null;\n        }\n        if (!data) {\n            return null;\n        }\n        // Check if this order belongs to one of the user's buildings\n        if (!userBuildingIds.includes(data.building_id)) {\n            console.warn(\"Order \".concat(id, \" does not belong to any building owned by user \").concat(user.id));\n            return null;\n        }\n        return data;\n    } catch (error) {\n        console.error('Error in getOrder:', error);\n        throw error;\n    }\n}\nasync function createOrder(orderInput) {\n    try {\n        // Get the current authenticated user\n        const { data: { user } } = await supabase.auth.getUser();\n        // Calculate total amount based on prices and quantities\n        const totalAmount = orderInput.items.reduce((sum, item)=>sum + item.price * item.quantity, 0);\n        // If this is a customer-initiated order, we don't need to verify building ownership\n        // But we should verify the building exists\n        const { data: buildingCheck } = await supabase.from('buildings').select('id').eq('id', orderInput.building_id).single();\n        if (!buildingCheck) {\n            throw new Error(\"Building with ID \".concat(orderInput.building_id, \" does not exist\"));\n        }\n        // Create the order first\n        const { data: orderData, error: orderError } = await supabase.from('orders').insert([\n            {\n                unit_id: orderInput.unit_id,\n                unit_number: orderInput.unit_number,\n                building_id: orderInput.building_id,\n                building_name: orderInput.building_name,\n                status: 'pending',\n                total_amount: totalAmount,\n                notes: orderInput.notes || ''\n            }\n        ]).select().single();\n        if (orderError) {\n            console.error('Error creating order:', orderError);\n            throw orderError;\n        }\n        if (!orderData) {\n            throw new Error('No data returned after creating order');\n        }\n        // Now create all the order items\n        const orderItems = orderInput.items.map((item)=>({\n                order_id: orderData.id,\n                item_type: item.item_type,\n                item_id: item.item_id,\n                name: item.name,\n                price: item.price,\n                quantity: item.quantity,\n                notes: item.notes || ''\n            }));\n        const { error: itemsError } = await supabase.from('order_items').insert(orderItems);\n        if (itemsError) {\n            console.error('Error creating order items:', itemsError);\n            // If there's an error creating order items, delete the order to maintain consistency\n            const { error: deleteError } = await supabase.from('orders').delete().eq('id', orderData.id);\n            if (deleteError) {\n                console.error('Error deleting order after failed items creation:', deleteError);\n            }\n            throw itemsError;\n        }\n        // Finally, fetch the complete order with items\n        return await getOrder(orderData.id);\n    } catch (error) {\n        console.error('Error in createOrder:', error);\n        throw error;\n    }\n}\nasync function updateOrderStatus(updateInput) {\n    try {\n        // Get the current authenticated user\n        const { data: { user } } = await supabase.auth.getUser();\n        if (!user) {\n            throw new Error('You must be logged in to update an order');\n        }\n        // Get the user's buildings\n        const { data: userBuildings } = await supabase.from('buildings').select('id').eq('user_id', user.id);\n        const userBuildingIds = (userBuildings === null || userBuildings === void 0 ? void 0 : userBuildings.map((b)=>b.id)) || [];\n        // First check if the order belongs to one of the user's buildings\n        const { data: orderData } = await supabase.from('orders').select('building_id').eq('id', updateInput.id).single();\n        if (!orderData || !userBuildingIds.includes(orderData.building_id)) {\n            throw new Error('You do not have permission to update this order');\n        }\n        const { data, error } = await supabase.from('orders').update({\n            status: updateInput.status,\n            updated_at: new Date().toISOString()\n        }).eq('id', updateInput.id).select().single();\n        if (error) {\n            throw error;\n        }\n        return await getOrder(updateInput.id);\n    } catch (error) {\n        console.error('Error in updateOrderStatus:', error);\n        throw error;\n    }\n}\nasync function deleteOrder(id) {\n    try {\n        // Get the current authenticated user\n        const { data: { user } } = await supabase.auth.getUser();\n        if (!user) {\n            throw new Error('You must be logged in to delete an order');\n        }\n        // Get the user's buildings\n        const { data: userBuildings } = await supabase.from('buildings').select('id').eq('user_id', user.id);\n        const userBuildingIds = (userBuildings === null || userBuildings === void 0 ? void 0 : userBuildings.map((b)=>b.id)) || [];\n        // First check if the order belongs to one of the user's buildings\n        const { data: orderData } = await supabase.from('orders').select('building_id').eq('id', id).single();\n        if (!orderData || !userBuildingIds.includes(orderData.building_id)) {\n            throw new Error('You do not have permission to delete this order');\n        }\n        // Delete the order - the cascade constraint will handle deleting associated items\n        const { error } = await supabase.from('orders').delete().eq('id', id);\n        if (error) {\n            throw error;\n        }\n    } catch (error) {\n        console.error('Error in deleteOrder:', error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9vcmRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBcUQ7QUFHckQsTUFBTUMsY0FBY0MsMENBQW9DO0FBQ3hELE1BQU1HLGtCQUFrQkgsa05BQXlDO0FBQ2pFLE1BQU1LLFdBQVdQLG1FQUFZQSxDQUFDQyxhQUFhSTtBQUVwQyxlQUFlRyxVQUFVQyxPQUkvQjtJQUNDLElBQUk7UUFDRixxQ0FBcUM7UUFDckMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRSxFQUFFQyxPQUFPQyxTQUFTLEVBQUUsR0FBRyxNQUFNTixTQUFTTyxJQUFJLENBQUNDLE9BQU87UUFFeEUsSUFBSUYsV0FBVztZQUNiRyxRQUFRSixLQUFLLENBQUMsZUFBZUM7WUFDN0IsTUFBTSxJQUFJSSxNQUFNLCtCQUFpRCxPQUFsQkosVUFBVUssT0FBTztRQUNsRTtRQUVBLElBQUksQ0FBQ1AsTUFBTTtZQUNUSyxRQUFRRyxJQUFJLENBQUM7WUFDYixPQUFPLEVBQUU7UUFDWDtRQUVBLHNEQUFzRDtRQUN0RCxNQUFNLEVBQUVULE1BQU1VLGFBQWEsRUFBRVIsT0FBT1MsY0FBYyxFQUFFLEdBQUcsTUFBTWQsU0FDMURlLElBQUksQ0FBQyxhQUNMQyxNQUFNLENBQUMsTUFDUEMsRUFBRSxDQUFDLFdBQVdiLEtBQUtjLEVBQUU7UUFFeEIsSUFBSUosZ0JBQWdCO1lBQ2xCTCxRQUFRSixLQUFLLENBQUMsc0NBQXNDUztZQUNwRCxNQUFNLElBQUlKLE1BQU0sbUNBQTBELE9BQXZCSSxlQUFlSCxPQUFPO1FBQzNFO1FBRUEsTUFBTVEsa0JBQWtCTixDQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWVPLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUgsRUFBRSxNQUFLLEVBQUU7UUFFM0QsSUFBSUMsZ0JBQWdCRyxNQUFNLEtBQUssR0FBRztZQUNoQyxPQUFPLEVBQUU7UUFDWDtRQUVBLElBQUlDLFFBQVF2QixTQUNUZSxJQUFJLENB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MEJBQUFBLG9DQUFBQSxjQUFlTyxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVILEVBQUUsTUFBSyxFQUFFO1FBRTNELGtFQUFrRTtRQUNsRSxNQUFNLEVBQUVmLE1BQU13QyxTQUFTLEVBQUUsR0FBRyxNQUFNM0MsU0FDL0JlLElBQUksQ0FBQyxVQUNMQyxNQUFNLENBQUMsZUFDUEMsRUFBRSxDQUFDLE1BQU1DLElBQ1RjLE1BQU07UUFFVCxJQUFJLENBQUNXLGFBQWEsQ0FBQ3hCLGdCQUFnQlUsUUFBUSxDQUFDYyxVQUFVZixXQUFXLEdBQUc7WUFDbEUsTUFBTSxJQUFJbEIsTUFBTTtRQUNsQjtRQUVBLGtGQUFrRjtRQUNsRixNQUFNLEVBQUVMLEtBQUssRUFBRSxHQUFHLE1BQU1MLFNBQ3JCZSxJQUFJLENBQUMsVUFDTDBDLE1BQU0sR0FDTnhDLEVBQUUsQ0FBQyxNQUFNQztRQUVaLElBQUliLE9BQU87WUFDVCxNQUFNQTtRQUNSO0lBQ0YsRUFBRSxPQUFPQSxPQUFPO1FBQ2RJLFFBQVFKLEtBQUssQ0FBQyx5QkFBeUJBO1FBQ3ZDLE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2pvZWxrd29oL0RvY3VtZW50cy9HaXRIdWIvbXlxcmNvZGUtaHViL2FwcC9zZXJ2aWNlcy9vcmRlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgT3JkZXIsIENyZWF0ZU9yZGVySW5wdXQsIFVwZGF0ZU9yZGVyU3RhdHVzSW5wdXQsIE9yZGVySXRlbSB9IGZyb20gJy4uL3R5cGVzL29yZGVyJztcblxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhO1xuY29uc3Qgc3VwYWJhc2VBbm9uS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkhO1xuY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSk7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPcmRlcnMoZmlsdGVycz86IHtcbiAgdW5pdF9pZD86IHN0cmluZztcbiAgYnVpbGRpbmdfaWQ/OiBzdHJpbmc7XG4gIHN0YXR1cz86IHN0cmluZztcbn0pOiBQcm9taXNlPE9yZGVyW10+IHtcbiAgdHJ5IHtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRlZCB1c2VyXG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgXG4gICAgaWYgKHVzZXJFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQXV0aCBlcnJvcjonLCB1c2VyRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IGN1cnJlbnQgdXNlcjogJHt1c2VyRXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIGF1dGhlbnRpY2F0ZWQgdXNlciBmb3VuZCcpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICAvLyBGaXJzdCwgZ2V0IHRoZSBsaXN0IG9mIGJ1aWxkaW5ncyBvd25lZCBieSB0aGlzIHVzZXJcbiAgICBjb25zdCB7IGRhdGE6IHVzZXJCdWlsZGluZ3MsIGVycm9yOiBidWlsZGluZ3NFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdidWlsZGluZ3MnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZCk7XG4gICAgICBcbiAgICBpZiAoYnVpbGRpbmdzRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIGZldGNoaW5nIGJ1aWxkaW5nczonLCBidWlsZGluZ3NFcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCB1c2VyIGJ1aWxkaW5nczogJHtidWlsZGluZ3NFcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB1c2VyQnVpbGRpbmdJZHMgPSB1c2VyQnVpbGRpbmdzPy5tYXAoYiA9PiBiLmlkKSB8fCBbXTtcbiAgICBcbiAgICBpZiAodXNlckJ1aWxkaW5nSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxuICAgICAgLmZyb20oJ29yZGVycycpXG4gICAgICAuc2VsZWN0KGBcbiAgICAgICAgKixcbiAgICAgICAgb3JkZXJfaXRlbXM6b3JkZXJfaXRlbXMoKilcbiAgICAgIGApXG4gICAgICAuaW4oJ2J1aWxkaW5nX2lkJywgdXNlckJ1aWxkaW5nSWRzKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuICAgIFxuICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICBpZiAoZmlsdGVycy51bml0X2lkKSB7XG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ3VuaXRfaWQnLCBmaWx0ZXJzLnVuaXRfaWQpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbHRlcnMuYnVpbGRpbmdfaWQpIHtcbiAgICAgICAgLy8gVmVyaWZ5IHRoZSBidWlsZGluZyBiZWxvbmdzIHRvIHRoZSB1c2VyIGJlZm9yZSBmaWx0ZXJpbmdcbiAgICAgICAgaWYgKHVzZXJCdWlsZGluZ0lkcy5pbmNsdWRlcyhmaWx0ZXJzLmJ1aWxkaW5nX2lkKSkge1xuICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ2J1aWxkaW5nX2lkJywgZmlsdGVycy5idWlsZGluZ19pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBCdWlsZGluZyAke2ZpbHRlcnMuYnVpbGRpbmdfaWR9IGRvZXMgbm90IGJlbG9uZyB0byB1c2VyICR7dXNlci5pZH1gKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXJzLnN0YXR1cykge1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdzdGF0dXMnLCBmaWx0ZXJzLnN0YXR1cyk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBvcmRlcnM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSBhcyBPcmRlcltdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldE9yZGVyczonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9yZGVyKGlkOiBzdHJpbmcpOiBQcm9taXNlPE9yZGVyIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBhdXRoZW50aWNhdGVkIHVzZXJcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICBcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgYmUgbG9nZ2VkIGluIHRvIHZpZXcgb3JkZXIgZGV0YWlscycpO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgdGhlIHVzZXIncyBidWlsZGluZ3NcbiAgICBjb25zdCB7IGRhdGE6IHVzZXJCdWlsZGluZ3MgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYnVpbGRpbmdzJylcbiAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpO1xuICAgICAgXG4gICAgY29uc3QgdXNlckJ1aWxkaW5nSWRzID0gdXNlckJ1aWxkaW5ncz8ubWFwKGIgPT4gYi5pZCkgfHwgW107XG4gICAgXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdvcmRlcnMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIG9yZGVyX2l0ZW1zOm9yZGVyX2l0ZW1zKCopXG4gICAgICBgKVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGlzIG9yZGVyIGJlbG9uZ3MgdG8gb25lIG9mIHRoZSB1c2VyJ3MgYnVpbGRpbmdzXG4gICAgaWYgKCF1c2VyQnVpbGRpbmdJZHMuaW5jbHVkZXMoZGF0YS5idWlsZGluZ19pZCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgT3JkZXIgJHtpZH0gZG9lcyBub3QgYmVsb25nIHRvIGFueSBidWlsZGluZyBvd25lZCBieSB1c2VyICR7dXNlci5pZH1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhIGFzIE9yZGVyO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldE9yZGVyOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlT3JkZXIob3JkZXJJbnB1dDogQ3JlYXRlT3JkZXJJbnB1dCk6IFByb21pc2U8T3JkZXI+IHtcbiAgdHJ5IHtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRlZCB1c2VyXG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHRvdGFsIGFtb3VudCBiYXNlZCBvbiBwcmljZXMgYW5kIHF1YW50aXRpZXNcbiAgICBjb25zdCB0b3RhbEFtb3VudCA9IG9yZGVySW5wdXQuaXRlbXMucmVkdWNlKFxuICAgICAgKHN1bSwgaXRlbSkgPT4gc3VtICsgKGl0ZW0ucHJpY2UgKiBpdGVtLnF1YW50aXR5KSwgXG4gICAgICAwXG4gICAgKTtcbiAgICBcbiAgICAvLyBJZiB0aGlzIGlzIGEgY3VzdG9tZXItaW5pdGlhdGVkIG9yZGVyLCB3ZSBkb24ndCBuZWVkIHRvIHZlcmlmeSBidWlsZGluZyBvd25lcnNoaXBcbiAgICAvLyBCdXQgd2Ugc2hvdWxkIHZlcmlmeSB0aGUgYnVpbGRpbmcgZXhpc3RzXG4gICAgY29uc3QgeyBkYXRhOiBidWlsZGluZ0NoZWNrIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2J1aWxkaW5ncycpXG4gICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAuZXEoJ2lkJywgb3JkZXJJbnB1dC5idWlsZGluZ19pZClcbiAgICAgIC5zaW5nbGUoKTtcbiAgICAgIFxuICAgIGlmICghYnVpbGRpbmdDaGVjaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCdWlsZGluZyB3aXRoIElEICR7b3JkZXJJbnB1dC5idWlsZGluZ19pZH0gZG9lcyBub3QgZXhpc3RgKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIG9yZGVyIGZpcnN0XG4gICAgY29uc3QgeyBkYXRhOiBvcmRlckRhdGEsIGVycm9yOiBvcmRlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ29yZGVycycpXG4gICAgICAuaW5zZXJ0KFt7XG4gICAgICAgIHVuaXRfaWQ6IG9yZGVySW5wdXQudW5pdF9pZCxcbiAgICAgICAgdW5pdF9udW1iZXI6IG9yZGVySW5wdXQudW5pdF9udW1iZXIsXG4gICAgICAgIGJ1aWxkaW5nX2lkOiBvcmRlcklucHV0LmJ1aWxkaW5nX2lkLFxuICAgICAgICBidWlsZGluZ19uYW1lOiBvcmRlcklucHV0LmJ1aWxkaW5nX25hbWUsXG4gICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICB0b3RhbF9hbW91bnQ6IHRvdGFsQW1vdW50LFxuICAgICAgICBub3Rlczogb3JkZXJJbnB1dC5ub3RlcyB8fCAnJ1xuICAgICAgfV0pXG4gICAgICAuc2VsZWN0KClcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChvcmRlckVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBvcmRlcjonLCBvcmRlckVycm9yKTtcbiAgICAgIHRocm93IG9yZGVyRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKCFvcmRlckRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YSByZXR1cm5lZCBhZnRlciBjcmVhdGluZyBvcmRlcicpO1xuICAgIH1cblxuICAgIC8vIE5vdyBjcmVhdGUgYWxsIHRoZSBvcmRlciBpdGVtc1xuICAgIGNvbnN0IG9yZGVySXRlbXMgPSBvcmRlcklucHV0Lml0ZW1zLm1hcChpdGVtID0+ICh7XG4gICAgICBvcmRlcl9pZDogb3JkZXJEYXRhLmlkLFxuICAgICAgaXRlbV90eXBlOiBpdGVtLml0ZW1fdHlwZSxcbiAgICAgIGl0ZW1faWQ6IGl0ZW0uaXRlbV9pZCxcbiAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgIHByaWNlOiBpdGVtLnByaWNlLFxuICAgICAgcXVhbnRpdHk6IGl0ZW0ucXVhbnRpdHksXG4gICAgICBub3RlczogaXRlbS5ub3RlcyB8fCAnJ1xuICAgIH0pKTtcblxuICAgIGNvbnN0IHsgZXJyb3I6IGl0ZW1zRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnb3JkZXJfaXRlbXMnKVxuICAgICAgLmluc2VydChvcmRlckl0ZW1zKTtcblxuICAgIGlmIChpdGVtc0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBvcmRlciBpdGVtczonLCBpdGVtc0Vycm9yKTtcbiAgICAgIFxuICAgICAgLy8gSWYgdGhlcmUncyBhbiBlcnJvciBjcmVhdGluZyBvcmRlciBpdGVtcywgZGVsZXRlIHRoZSBvcmRlciB0byBtYWludGFpbiBjb25zaXN0ZW5jeVxuICAgICAgY29uc3QgeyBlcnJvcjogZGVsZXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdvcmRlcnMnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIG9yZGVyRGF0YS5pZCk7XG4gICAgICBcbiAgICAgIGlmIChkZWxldGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBvcmRlciBhZnRlciBmYWlsZWQgaXRlbXMgY3JlYXRpb246JywgZGVsZXRlRXJyb3IpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBpdGVtc0Vycm9yO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIGZldGNoIHRoZSBjb21wbGV0ZSBvcmRlciB3aXRoIGl0ZW1zXG4gICAgcmV0dXJuIGF3YWl0IGdldE9yZGVyKG9yZGVyRGF0YS5pZCkgYXMgT3JkZXI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY3JlYXRlT3JkZXI6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVPcmRlclN0YXR1cyh1cGRhdGVJbnB1dDogVXBkYXRlT3JkZXJTdGF0dXNJbnB1dCk6IFByb21pc2U8T3JkZXI+IHtcbiAgdHJ5IHtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRlZCB1c2VyXG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgXG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGJlIGxvZ2dlZCBpbiB0byB1cGRhdGUgYW4gb3JkZXInKTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IHRoZSB1c2VyJ3MgYnVpbGRpbmdzXG4gICAgY29uc3QgeyBkYXRhOiB1c2VyQnVpbGRpbmdzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2J1aWxkaW5ncycpXG4gICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKTtcbiAgICAgIFxuICAgIGNvbnN0IHVzZXJCdWlsZGluZ0lkcyA9IHVzZXJCdWlsZGluZ3M/Lm1hcChiID0+IGIuaWQpIHx8IFtdO1xuICAgIFxuICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBvcmRlciBiZWxvbmdzIHRvIG9uZSBvZiB0aGUgdXNlcidzIGJ1aWxkaW5nc1xuICAgIGNvbnN0IHsgZGF0YTogb3JkZXJEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ29yZGVycycpXG4gICAgICAuc2VsZWN0KCdidWlsZGluZ19pZCcpXG4gICAgICAuZXEoJ2lkJywgdXBkYXRlSW5wdXQuaWQpXG4gICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICBpZiAoIW9yZGVyRGF0YSB8fCAhdXNlckJ1aWxkaW5nSWRzLmluY2x1ZGVzKG9yZGVyRGF0YS5idWlsZGluZ19pZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gdXBkYXRlIHRoaXMgb3JkZXInKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdvcmRlcnMnKVxuICAgICAgLnVwZGF0ZSh7IFxuICAgICAgICBzdGF0dXM6IHVwZGF0ZUlucHV0LnN0YXR1cyxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9KVxuICAgICAgLmVxKCdpZCcsIHVwZGF0ZUlucHV0LmlkKVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBnZXRPcmRlcih1cGRhdGVJbnB1dC5pZCkgYXMgT3JkZXI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdXBkYXRlT3JkZXJTdGF0dXM6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVPcmRlcihpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0ZWQgdXNlclxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgIFxuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBiZSBsb2dnZWQgaW4gdG8gZGVsZXRlIGFuIG9yZGVyJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEdldCB0aGUgdXNlcidzIGJ1aWxkaW5nc1xuICAgIGNvbnN0IHsgZGF0YTogdXNlckJ1aWxkaW5ncyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdidWlsZGluZ3MnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZCk7XG4gICAgICBcbiAgICBjb25zdCB1c2VyQnVpbGRpbmdJZHMgPSB1c2VyQnVpbGRpbmdzPy5tYXAoYiA9PiBiLmlkKSB8fCBbXTtcbiAgICBcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgb3JkZXIgYmVsb25ncyB0byBvbmUgb2YgdGhlIHVzZXIncyBidWlsZGluZ3NcbiAgICBjb25zdCB7IGRhdGE6IG9yZGVyRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdvcmRlcnMnKVxuICAgICAgLnNlbGVjdCgnYnVpbGRpbmdfaWQnKVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgaWYgKCFvcmRlckRhdGEgfHwgIXVzZXJCdWlsZGluZ0lkcy5pbmNsdWRlcyhvcmRlckRhdGEuYnVpbGRpbmdfaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGRlbGV0ZSB0aGlzIG9yZGVyJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIERlbGV0ZSB0aGUgb3JkZXIgLSB0aGUgY2FzY2FkZSBjb25zdHJhaW50IHdpbGwgaGFuZGxlIGRlbGV0aW5nIGFzc29jaWF0ZWQgaXRlbXNcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ29yZGVycycpXG4gICAgICAuZGVsZXRlKClcbiAgICAgIC5lcSgnaWQnLCBpZCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBkZWxldGVPcmRlcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn0gIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwic3VwYWJhc2UiLCJnZXRPcmRlcnMiLCJmaWx0ZXJzIiwiZGF0YSIsInVzZXIiLCJlcnJvciIsInVzZXJFcnJvciIsImF1dGgiLCJnZXRVc2VyIiwiY29uc29sZSIsIkVycm9yIiwibWVzc2FnZSIsIndhcm4iLCJ1c2VyQnVpbGRpbmdzIiwiYnVpbGRpbmdzRXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJpZCIsInVzZXJCdWlsZGluZ0lkcyIsIm1hcCIsImIiLCJsZW5ndGgiLCJxdWVyeSIsImluIiwib3JkZXIiLCJhc2NlbmRpbmciLCJ1bml0X2lkIiwiYnVpbGRpbmdfaWQiLCJpbmNsdWRlcyIsInN0YXR1cyIsImdldE9yZGVyIiwic2luZ2xlIiwiY3JlYXRlT3JkZXIiLCJvcmRlcklucHV0IiwidG90YWxBbW91bnQiLCJpdGVtcyIsInJlZHVjZSIsInN1bSIsIml0ZW0iLCJwcmljZSIsInF1YW50aXR5IiwiYnVpbGRpbmdDaGVjayIsIm9yZGVyRGF0YSIsIm9yZGVyRXJyb3IiLCJpbnNlcnQiLCJ1bml0X251bWJlciIsImJ1aWxkaW5nX25hbWUiLCJ0b3RhbF9hbW91bnQiLCJub3RlcyIsIm9yZGVySXRlbXMiLCJvcmRlcl9pZCIsIml0ZW1fdHlwZSIsIml0ZW1faWQiLCJuYW1lIiwiaXRlbXNFcnJvciIsImRlbGV0ZUVycm9yIiwiZGVsZXRlIiwidXBkYXRlT3JkZXJTdGF0dXMiLCJ1cGRhdGVJbnB1dCIsInVwZGF0ZSIsInVwZGF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJkZWxldGVPcmRlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/order.ts\n"));

/***/ })

});